/* Define an at-style function like fstatat, unlinkat, fchownat, etc.
   Copyright (C) 2008 Free Software Foundation, Inc.
   Based on at-func.c written by Jim Meyering.
   Contributed by David Bartley <dtbartle@csclub.uwaterloo.ca>.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
   02111-1307 USA.  */

#include <inline-syscall.h>
#include <errno.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <memory.h>
#include <fcntl.h>
#include <assert.h>
#include <signal.h>
#include <bits/libc-lock.h>

DECLARE_INLINE_SYSCALL (int, fchdir, int fd);

#ifdef IS_IN_rtld
# error rtld should not call be calling an at-style function
#endif

__libc_lock_define (extern, cwd_lock);

#ifndef AT_FUNC_PRE_FILE_ARGS
# define AT_FUNC_PRE_FILE_ARGS
#endif
#ifndef AT_FUNC_POST_FILE_ARGS
# define AT_FUNC_POST_FILE_ARGS
#endif
#ifndef AT_FUNC_PRE_FILE_PARAM_DECLS
# define AT_FUNC_PRE_FILE_PARAM_DECLS
#endif
#ifndef AT_FUNC_POST_FILE_PARAM_DECLS
# define AT_FUNC_POST_FILE_PARAM_DECLS
#endif

#define CALL_FUNC(F) \
  AT_FUNC_FUNC (AT_FUNC_PRE_FILE_ARGS F AT_FUNC_POST_FILE_ARGS)

/* Change to the directory given by dirfd, call AT_FUNC_FUNC to
  operate on file, then restore the original working directory. */
int
AT_FUNC_NAME (AT_FUNC_PRE_FILE_PARAM_DECLS int dirfd, const char *file AT_FUNC_POST_FILE_PARAM_DECLS)
{
  int result;

  if(dirfd == AT_FDCWD || (file && (file[0] == '/')))
    return CALL_FUNC (file);

  /* block all signals and lock cwd */
  sigset_t fillset, oldset;
  if(sigfillset (&fillset) != 0)
    return -1;
  if(sigprocmask (SIG_SETMASK, &fillset, &oldset) != 0)
    return -1;
  __libc_lock_lock (cwd_lock);

  int dirfd_saved_cwd = open (".", O_DIRECTORY | O_RDONLY);
  if (dirfd_saved_cwd == -1)
    goto error;

  /* note that we need to use the syscall since fchdir locks cwd */
  result = INLINE_SYSCALL (fchdir, 1, dirfd);
  if (fchdir (dirfd) == -1)
    goto error;

	result = CALL_FUNC (file);
    if(result == -1)
        goto error;

  assert (INLINE_SYSCALL(fchdir, 1, dirfd_saved_cwd) == 0);

  /* unlock cwd and restore signals */
  __libc_lock_unlock (cwd_lock);
  assert (sigprocmask (SIG_SETMASK, &oldset, NULL) == 0);

  return result;

error:
  __libc_lock_unlock (cwd_lock);
  assert (sigprocmask (SIG_SETMASK, &oldset, NULL) == 0);

  return -1;
}
#undef CALL_FUNC
