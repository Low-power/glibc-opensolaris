/* Support macros for making weak and strong aliases for symbols,
   and for using symbol sets and linker warnings with GNU ld.
Copyright (C) 1995 Free Software Foundation, Inc.
This file is part of the GNU C Library.

The GNU C Library is free software; you can redistribute it and/or
modify it under the terms of the GNU Library General Public License as
published by the Free Software Foundation; either version 2 of the
License, or (at your option) any later version.

The GNU C Library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Library General Public License for more details.

You should have received a copy of the GNU Library General Public
License along with the GNU C Library; see the file COPYING.LIB.  If
not, write to the Free Software Foundation, Inc., 675 Mass Ave,
Cambridge, MA 02139, USA.  */

#ifndef _LIBC_SYMBOLS_H
#define _LIBC_SYMBOLS_H

/* This file's macros are included implicitly in the compilation of every
   file in the C library by -imacros.

   We include config.h which is generated by configure.
   It should define for us the following symbols:

   * HAVE_GNU_LD if using GNU ld, with support for weak symbols in a.out,
   and for symbol set and warning messages extensions in a.out and ELF.
   This implies HAVE_WEAK_SYMBOLS; set by --with-gnu-ld.
   * HAVE_ELF if using ELF, which supports weak symbols.
   This implies HAVE_WEAK_SYMBOLS; set by --with-elf.

   * HAVE_WEAK_SYMBOLS if weak symbols are available in the assembler and
   linker being used.  Set by --with-weak-symbols.

   */
#include <config.h>

/* This is defined for the compilation of all C library code.
   features.h tests this to avoid inclusion of stubs.h while
   compiling the library, before stubs.h has been generated.
   Some library code that is shared with other packages also
   tests this symbol to see if it is being compiled as part
   of the C library.  */
#define _LIBC

/* The symbols in all the user (non-_) macros are C symbols.  Predefined
   should be HAVE_WEAK_SYMBOLS and/or HAVE_ELF and/or HAVE_GNU_LD.
   HAVE_WEAK_SYMBOLS is implied by the other two.  HAVE_GNU_LD without
   HAVE_ELF implies a.out.  */

#ifndef HAVE_WEAK_SYMBOLS
#if defined (HAVE_ELF) || defined (HAVE_GNU_LD)
#define HAVE_WEAK_SYMBOLS
#endif
#endif

#ifndef __SYMBOL_PREFIX
#ifdef HAVE_ELF
#define NO_UNDERSCORES
#else
#include <sysdep.h>		/* Should define NO_UNDERSCORES.  */
#endif
#ifdef NO_UNDERSCORES
#define __SYMBOL_PREFIX
#else
#define __SYMBOL_PREFIX "_"
#endif
#endif

#ifndef C_SYMBOL_NAME
#ifdef NO_UNDERSCORES
#define C_SYMBOL_NAME(name) name
#else
#define C_SYMBOL_NAME(name) _##name
#endif
#endif


/* Define ALIAS as a strong alias for ORIGINAL.  */
#ifdef HAVE_ASM_SET_DIRECTIVE
#define strong_alias_asm(original, alias)	\
  ASM_GLOBAL_DIRECTIVE C_SYMBOL_NAME (alias);	\
  .set C_SYMBOL_NAME (alias),C_SYMBOL_NAME (original)
#ifdef ASSEMBLER
#define strong_alias(original, alias)	strong_alias_asm (original, alias)
#else
#define strong_alias(original, alias)	\
  asm (__string_1 (ASM_GLOBAL_DIRECTIVE) " " __SYMBOL_PREFIX #alias "\n" \
       ".set " __SYMBOL_PREFIX #alias "," __SYMBOL_PREFIX #original);
#endif
#else
#define strong_alias_asm(original, alias)	\
  ASM_GLOBAL_DIRECTIVE C_SYMBOL_NAME (alias);	\
  C_SYMBOL_NAME (alias) = C_SYMBOL_NAME (original)
#ifdef ASSEMBLER
#define strong_alias(original, alias)	strong_alias_asm (original, alias)
#else
#define strong_alias(original, alias)	\
  asm (__string_1 (ASM_GLOBAL_DIRECTIVE) " " __SYMBOL_PREFIX #alias "\n" \
       __SYMBOL_PREFIX #alias " = " __SYMBOL_PREFIX #original);
#endif
#endif

/* Helper macros used above.  */
#define __string_1(x) __string_0(x)
#define __string_0(x) #x


#ifdef HAVE_WEAK_SYMBOLS
#ifdef ASSEMBLER

/* Define ALIAS as a weak alias for ORIGINAL.
   If weak aliases are not available, this defines a strong alias.  */
#define weak_alias(original, alias)	\
  .weak C_SYMBOL_NAME (alias);	\
  C_SYMBOL_NAME (alias) = C_SYMBOL_NAME (original)

/* Declare SYMBOL to be weak.  */
#define weak_symbol(symbol)	.weak C_SYMBOL_NAME (symbol)

#else
#define weak_symbol(symbol)	asm (".weak " __SYMBOL_PREFIX #symbol);
#define weak_alias(original, alias) \
  asm (".weak " __SYMBOL_PREFIX #alias "\n" \
       __SYMBOL_PREFIX #alias " = " __SYMBOL_PREFIX #original);
#endif
#else
#define	weak_alias(original, alias) strong_alias(original, alias)
#define weak_symbol(symbol)	/* Do nothing.  */
#endif



/* When the file using this macro is linked in, the linker
   will emit a warning message MSG.  */
#ifdef HAVE_GNU_LD
#ifdef HAVE_ELF
#define link_warning(msg)			\
  static const char __evoke_link_warning__[]	\
    __attribute__ ((section (".gnu.warning"))) = msg;
#else
#define link_warning(msg)		\
  asm(".stabs \"" msg "\",30,0,0,0\n"	\
      ".stabs \"__evoke_link_warning__\",1,0,0,0\n"\
      ".stabs \"__evoke_link_warning__\",2,0,0,0\n");
#endif
#else
/* We will never be heard; they will all die horribly.  */
#define link_warning(msg)
#endif

/* A canned warning for sysdeps/stub functions.  */
#define	stub_warning(name) \
  link_warning ("warning: " #name " is not implemented and will always fail")

/*

*/

#ifdef HAVE_GNU_LD

/* Symbol set support macros.  */

#ifdef HAVE_ELF

/* Make SYMBOL, which is in the text segment, an element of SET.  */
#define text_set_element(set, symbol)	_elf_set_element(set, symbol)
/* Make SYMBOL, which is in the data segment, an element of SET.  */
#define data_set_element(set, symbol)	_elf_set_element(set, symbol)
/* Make SYMBOL, which is in the bss segment, an element of SET.  */
#define bss_set_element(set, symbol)	_elf_set_element(set, symbol)

/* These are all done the same way in ELF.
   There is a new section created for each set.  */
#ifdef PIC
/* When building a shared library, make the set section writable,
   because it will need to be relocated at run time anyway.  */
#define _elf_set_element(set, symbol) \
  static const void *__elf_set_##set##_element_##symbol##__ \
    __attribute__ ((unused, section (#set))) = &(symbol)
#else
#define _elf_set_element(set, symbol) \
  static const void *const __elf_set_##set##_element_##symbol##__ \
    __attribute__ ((unused, section (#set))) = &(symbol)
#endif

/* Define SET as a symbol set.  This may be required (it is in a.out) to
   be able to use the set's contents.  */
#define symbol_set_define(set)	symbol_set_declare(set)

/* Declare SET for use in this module, if defined in another module.  */
#define symbol_set_declare(set)	\
  extern void *const __start_##set, *const __stop_##set;

/* Return a pointer (void *const *) to the first element of SET.  */
#define symbol_set_first_element(set)	(&__start_##set)

/* Return true iff PTR (a void *const *) has been incremented
   past the last element in SET.  */
#define symbol_set_end_p(set, ptr)	((ptr) >= &__stop_##set)

#else	/* Not ELF: a.out.  */

#define	text_set_element(set, symbol)	\
  asm(".stabs \"" __SYMBOL_PREFIX #set "\",23,0,0," __SYMBOL_PREFIX #symbol)
#define	data_set_element(set, symbol)	\
  asm(".stabs \"" __SYMBOL_PREFIX #set "\",25,0,0," __SYMBOL_PREFIX #symbol)
#define	bss_set_element(set, symbol)	?error Must use initialized data.
#define symbol_set_define(set)		void *const (set)[1];
#define symbol_set_declare(set)		extern void *const (set)[1];

#define symbol_set_first_element(set)	&(set)[1]
#define symbol_set_end_p(set, ptr)	(*(ptr) == 0)

#endif	/* ELF.  */
#endif	/* Have GNU ld.  */

#endif /* libc-symbols.h */
