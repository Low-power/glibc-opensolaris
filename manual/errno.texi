@node Error Reporting
@chapter Error Reporting
@cindex error reporting
@cindex reporting errors
@cindex error codes
@cindex status codes

Many functions in the GNU C library detect and report error conditions,
and sometimes your programs need to check for these error conditions.
For example, if your program needs to open an input file, you should
make sure that the file was actually opened correctly before trying to
read from it, and print an error message or take other appropriate
action if the call to the library function failed.

This chapter describes how the error reporting facility works.  Your
program should include the header file @file{errno.h} to use this
facility.
@pindex errno.h

@menu
* Checking for Errors::	How errors are reported.
* Error Codes::		Symbolic names for error codes.
* Error Messages::	Mapping error codes onto error messages.
@end menu

@node Checking for Errors
@section Checking for Errors

Most library functions return a special value to indicate that they have
failed.  This is often a value of @code{-1}, a null pointer, or a
constant such as @code{EOF} that is defined for that purpose.  But this
a return value tells you only that an error has occurred.  To find out
what went wrong, you need to look at the error code stored in the
variable @code{errno}.  This variable is declared in the header file
@file{errno.h}.
@pindex errno.h

@comment errno.h
@comment ANSI
@deftypevr {Variable} {volatile int} errno
The variable @code{errno} contains the system error number.  You can
change the value of @code{errno}.

Since @code{errno} is declared @code{volatile}, it might be changed
asynchronously by a signal handler; @pxref{Defining a Signal Handler}.
However, a properly written signal handler saves and restores the value
of @code{errno}, so you generally do not need to worry about this
possibility in ordinary code.

The initial value of @code{errno} at program startup is zero.  Many
library functions are guaranteed to set it to certain nonzero values
when they encounter certain kinds of errors.  These error conditions are
listed for each function.  No library funciton ever stores zero in
@code{errno}.
@end deftypevr

@strong{Portability Note:} ANSI C specifies @code{errno} as a
``modifiable lvalue'' rather than as a variable, permitting it to be
implemented as a macro.  For example, its expansion might involve a
function call, like @code{*_errno ()}.  But in the GNU system,
@code{errno} really is a variable.

There are a few library functions, like @code{sqrt} and @code{atan},
that return a perfectly legitimate value in case of an error, but also
set @code{errno}.  For these functions, if you want to check to see
whether an error occurred, the recommended method is to set @code{errno}
to zero before calling the function, and then check its value afterward.

All the error codes have symbolic names, macros defined in
@file{errno.h}.  The names start with @samp{E} and an upper-case
letter or digit, and you should consider names of this form to be
reserved names.  @xref{Reserved Names}.
@pindex errno.h

The error code values are all positive integers and all distinct.
(Since the values are distinct, you can use them as labels in a
@code{switch} statement, for example.)  Your program should not make any
other assumptions about the specific values of these symbolic constants.

The value of @code{errno} doesn't necessarily have to correspond to any
of these macros, since implementations might define additional error
codes of their own for other situations.  The only values that are
guaranteed to be meaningful for a particular library function are the
ones that this manual explicitly lists for that function.

Here is an example showing how to handle failure to open a file
correctly.  The function @code{open_sesame} tries to open the named file
for reading and returns a stream if successful.  The @code{fopen}
library function returns a null pointer if it couldn't open the file for
some reason.  In that situation, this example constructs an appropriate
error message using the @code{strerror} function, and the program exits.
If we were going to make some other library calls before passing the
error code to @code{strerror}, we'd have to save it in a local variable
instead, because those other library functions might overwrite
@code{errno} in the meantime.

@example
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

extern char *program_name;

FILE *
open_sesame (char *name)
@{ 
  FILE *stream;

  errno = 0;                     
  stream = fopen (name, "r");
  if (!stream) @{
    fprintf (stderr, "%s: Couldn't open file %s; %s\n",
             program_name, name, strerror (errno));
    exit (EXIT_FAILURE);
    @}
  else
    return stream;
@}
@end example


@node Error Codes
@section Error Codes

These macros are defined in the header file @file{errno.h}.  All of
them expand into integer constant values.  Some of these error codes
can't occur on the GNU system, but they can occur using the GNU library
on other systems.
@pindex errno.h


@comment errno.h
@comment BSD
@deftypevr Macro int EIDRM      @c ????
A message queue identifier has been removed and is no longer valid.
@end deftypevr

@comment errno.h
@comment BSD
@deftypevr Macro int ENOMSG     @c ???
There is no message of the specified type available immediately, and
blocking was not desired.
@end deftypevr

@comment errno.h
@comment POSIX.1
@deftypevr Macro int EPERM      @c 1 Operation not permitted
Operation not permitted; only the owner of the file (or other resource)
or processes with special privileges can perform the operation.
@end deftypevr

@comment errno.h
@comment POSIX.1
@deftypevr Macro int ENOENT     @c 2 No such file or directory
No such file or directory.  This is a ``file doesn't exist'' error
for ordinary files that are referenced in contexts where they are
expected to already exist.
@end deftypevr

@comment errno.h
@comment POSIX.1
@deftypevr Macro int ESRCH      @c 3 No such process
There is no such process that matches the specified process ID.
@end deftypevr

@comment errno.h
@comment POSIX.1
@deftypevr Macro int EINTR      @c 4 Interrupted system call
Interrupted function call; an asynchronous signal occured and prevented
completion of the call.  When this happens, you should try the call
again.
@end deftypevr

@comment errno.h
@comment POSIX.1
@deftypevr Macro int EIO        @c 5 Input/output error
Input/output error; usually used for physical read or write errors.
@end deftypevr

@comment errno.h
@comment POSIX.1
@deftypevr Macro int ENXIO      @c 6 Device not configured
No such device or address.  Typically, this means that a file
representing a device has been installed incorrectly, and the
system can't find the right kind of device driver for it.
@end deftypevr

@comment errno.h
@comment POSIX.1
@deftypevr Macro int E2BIG      @c 7 Argument list too long
Argument list too long; used when the arguments passed to a new program
being executed with one of the @code{exec} functions (@pxref{Executing a
File}) are too large.  This condition never arises in the GNU system.
@end deftypevr

@comment errno.h
@comment POSIX.1
@deftypevr Macro int ENOEXEC    @c 8 Exec format error
Invalid executable file format.  This condition is detected by the
@code{exec} functions; @pxref{Executing a File}.
@end deftypevr

@comment errno.h
@comment POSIX.1
@deftypevr Macro int EBADF      @c 9 Bad file descriptor
Bad file descriptor; the file might have been closed or perhaps you are
trying to read to a file open only for writing (or vice versa).
@end deftypevr

@comment errno.h
@comment POSIX.1
@deftypevr Macro int ECHILD     @c 10 No child processes
There are no child processes.  This error happens on operations that are
supposed to manipulate child processes, when there aren't any processes
to manipulate.
@end deftypevr

@comment errno.h
@comment POSIX.1
@deftypevr Macro int EDEADLK    @c 11 Resource deadlock avoided
Deadlock avoided; allocating a system resource would have resulted in
a deadlock situation.  For an example, @xref{File Locks}.
@end deftypevr

@comment errno.h
@comment POSIX.1
@deftypevr Macro int ENOMEM     @c 12 Cannot allocate memory
Not enough memory available.
@end deftypevr

@comment errno.h
@comment POSIX.1
@deftypevr Macro int EACCES     @c 13 Permission denied
Permission denied; the file permissions do not allow the attempted access.
@end deftypevr

@comment errno.h
@comment POSIX.1
@deftypevr Macro int EFAULT     @c 14 Bad address
Bad address; an invalid pointer was detected.
@end deftypevr

@comment errno.h
@comment BSD
@deftypevr Macro int ENOTBLK    @c 15 Block device required
A file that isn't a block special file was given in a situation that
requires one.  For example, trying to mount an ordinary file as a file
system will give this error.
@end deftypevr

@comment errno.h
@comment POSIX.1
@deftypevr Macro int EBUSY      @c 16 Device busy
Resource busy; a system resource that can't be shared is already in use.
For example, if you try to delete a file that is the root of a currently
mounted filesystem, you get this error.
@end deftypevr

@comment errno.h
@comment POSIX.1
@deftypevr Macro int EEXIST     @c 17 File exists
File exists; an existing file was specified in a context where it only
makes sense to specify a new file.
@end deftypevr

@comment errno.h
@comment POSIX.1
@deftypevr Macro int EXDEV      @c 18 Invalid cross-device link
An attempt to make an improper link across file systems was detected.
@end deftypevr

@comment errno.h
@comment POSIX.1
@deftypevr Macro int ENODEV     @c 19 Operation not supported by device
No such device.  This a ``file doesn't exist'' error, but is
used only when the file is expected to represent a device, like a
block special file for a disk.
@end deftypevr

@comment errno.h
@comment POSIX.1
@deftypevr Macro int ENOTDIR    @c 20 Not a directory
A file that isn't a directory was given in a situation that requires
one.
@end deftypevr

@comment errno.h
@comment POSIX.1
@deftypevr Macro int EISDIR     @c 21 Is a directory
File is a directory; it can't be written to like an ordinary file.
@end deftypevr

@comment errno.h
@comment POSIX.1
@deftypevr Macro int EINVAL     @c 22 Invalid argument
Invalid argument.  This is used to indicate various kinds of problems
with passing the wrong argument to a library function.
@end deftypevr

@comment errno.h
@comment POSIX.1
@deftypevr Macro int ENFILE     @c 23 Too many open files in system
There are too many files open in the entire system.
@end deftypevr

@comment errno.h
@comment POSIX.1
@deftypevr Macro int EMFILE     @c 24 Too many open files
The process has too many files open and can't open any more.
@c In GNU, use setdtablesize.
@end deftypevr

@comment errno.h
@comment POSIX.1
@deftypevr Macro int ENOTTY     @c 25 Inappropriate ioctl for device
Inappropriate I/O control operation, such as trying to set terminal
modes on an ordinary file.
@end deftypevr

@comment errno.h
@comment BSD
@deftypevr Macro int ETXTBSY    @c 26 Text file busy
An attempt to execute a file that is currently open for writing, or
write to a file that is currently being executed.  (The name stands
for ``text file busy''.)  This is not an error in the GNU system; the
text is copied as necessary.
@end deftypevr

@comment errno.h
@comment POSIX.1
@deftypevr Macro int EFBIG      @c 27 File too large
File too big; the size of a file would be larger than allowed by the system.
@end deftypevr

@comment errno.h
@comment POSIX.1
@deftypevr Macro int ENOSPC     @c 28 No space left on device
No space left on device; write operation on a file failed because the
device is full.
@end deftypevr

@comment errno.h
@comment POSIX.1
@deftypevr Macro int ESPIPE     @c 29 Illegal seek
Invalid seek operation (such as on a pipe).
@end deftypevr

@comment errno.h
@comment POSIX.1
@deftypevr Macro int EROFS      @c 30 Read-only file system
An attempt was made to modify a file on a read-only file system.
@end deftypevr

@comment errno.h
@comment POSIX.1
@deftypevr Macro int EMLINK     @c 31 Too many links
Too many links; the link count of a single file is too large.
@end deftypevr

@comment errno.h
@comment POSIX.1
@deftypevr Macro int EPIPE      @c 32 Broken pipe
Broken pipe; there is no process reading from the other end of a pipe.
@end deftypevr

@comment errno.h
@comment ANSI
@deftypevr Macro int EDOM       @c 33 Numerical argument out of domain
Domain error; used by mathematical functions when an argument value does
not fall into the domain over which the function is defined.
@end deftypevr

@comment errno.h
@comment ANSI
@deftypevr Macro int ERANGE     @c 34 Numerical result out of range
Range error; used by mathematical functions when the result value is
not representable because of overflow or underflow.
@end deftypevr

@comment errno.h
@comment POSIX.1
@deftypevr Macro int EAGAIN     @c 35 Resource temporarily unavailable
Resource temporarily unavailable; the call might work if you try again
later.
@end deftypevr

@comment errno.h
@comment BSD
@deftypevr Macro int EWOULDBLOCK @c EAGAIN Operation would block
An operation that would block was attempted on an object that has
non-blocking mode selected.

@strong{Portability Note:} In 4.4BSD and GNU, @code{EWOULDBLOCK} and
@code{EAGAIN} are the same.  Earlier versions of BSD (@pxref{Berkeley
Unix}) have two distinct codes, and use @code{EWOULDBLOCK} to indicate
an i/o operation that would block on an object with non-blocking mode
set, and @code{EAGAIN} for other kinds of errors.@refill
@end deftypevr

@comment errno.h
@comment BSD
@deftypevr Macro int EINPROGRESS @c 36 Operation now in progress
An operation that cannot complete immediately was initiated on an object
that has non-blocking mode selected.
@end deftypevr

@comment errno.h
@comment BSD
@deftypevr Macro int EALREADY   @c 37 Operation already in progress
An operation is already in progress on an object that has non-blocking
mode selected.
@end deftypevr

@comment errno.h
@comment BSD
@deftypevr Macro int ENOTSOCK   @c 38 Socket operation on non-socket
A file that isn't a socket was given in a situation that requires one.
@end deftypevr

@comment errno.h
@comment BSD
@deftypevr Macro int EDESTADDRREQ @c 39 Destination address required
No destination address was supplied on a socket operation.
@end deftypevr

@comment errno.h
@comment BSD
@deftypevr Macro int EMSGSIZE   @c 40 Message too long
The size of a message sent on a socket was larger than the supported
maximum size.  
@end deftypevr

@comment errno.h
@comment BSD
@deftypevr Macro int EPROTOTYPE @c 41 Protocol wrong type for socket
The socket type does not support the requested communications protocol.
@end deftypevr

@comment errno.h
@comment BSD
@deftypevr Macro int ENOPROTOOPT @c 42 Protocol not available
You specified a socket option that doesn't make sense for the
particular protocol being used by the socket.  @xref{Socket Options}.
@end deftypevr

@comment errno.h
@comment BSD
@deftypevr Macro int EPROTONOSUPPORT @c 43 Protocol not supported
The socket domain does not support the requested communications protocol.
@xref{Creating a Socket}.
@end deftypevr

@comment errno.h
@comment BSD
@deftypevr Macro int ESOCKTNOSUPPORT @c 44 Socket type not supported
The socket type is not supported.
@end deftypevr

@comment errno.h
@comment BSD
@deftypevr Macro int EOPNOTSUPP @c 45 Operation not supported
The operation you requested is not supported.  Some socket functions
don't make sense for all types of sockets, and others may not be implemented
for all communications protocols.
@end deftypevr

@comment errno.h
@comment BSD
@deftypevr Macro int EPFNOSUPPORT @c 46 Protocol family not supported
The socket communications protocol family you requested is not supported.
@end deftypevr

@comment errno.h
@comment BSD
@deftypevr Macro int EAFNOSUPPORT @c 47 Address family not supported by protocol family
The address family specified for a socket is not supported; it is
inconsistent with the protocol being used on the socket.  @xref{Sockets}.
@end deftypevr

@comment errno.h
@comment BSD
@deftypevr Macro int EADDRINUSE @c 48 Address already in use
The socket address is already in use.  @xref{Socket Naming}.
@end deftypevr

@comment errno.h
@comment BSD
@deftypevr Macro int EADDRNOTAVAIL @c 49 Can't assign requested address
The requested socket address is not available; for example, you tried
to give a socket a name that doesn't match the local host name.
@xref{Socket Naming}.
@end deftypevr

@comment errno.h
@comment BSD
@deftypevr Macro int ENETDOWN   @c 50 Network is down
A socket operation failed because the network was down.
@end deftypevr

@comment errno.h
@comment BSD
@deftypevr Macro int ENETUNREACH @c 51 Network is unreachable
A socket operation failed because the network was unreachable.
@end deftypevr

@comment errno.h
@comment BSD
@deftypevr Macro int ENETRESET  @c 52 Network dropped connection on reset
The network connection was reset because the remote host crashed.
@end deftypevr

@comment errno.h
@comment BSD
@deftypevr Macro int ECONNABORTED @c 53 Software caused connection abort
A network connection was aborted locally.
@end deftypevr

@comment errno.h
@comment BSD
@deftypevr Macro int ECONNRESET @c 54 Connection reset by peer
A network connection was closed, such as by the remote machine rebooting.
@end deftypevr

@comment errno.h
@comment BSD
@deftypevr Macro int ENOBUFS    @c 55 No buffer space available
No internal buffer space available for an operation on a pipe or socket.
@end deftypevr

@comment errno.h
@comment BSD
@deftypevr Macro int EISCONN    @c 56 Socket is already connected
You tried to connect a socket that is already connected.
@xref{Establishing a Connection}.
@end deftypevr

@comment errno.h
@comment BSD
@deftypevr Macro int ENOTCONN   @c 57 Socket is not connected
The socket is not connected to anything.  You get this message when you
try to transmit data over a socket, without first specifying a destination
for the data.
@end deftypevr

@comment errno.h
@comment BSD
@deftypevr Macro int ESHUTDOWN  @c 58 Can't send after socket shutdown
The socket has already been shut down.
@end deftypevr

@comment errno.h
@comment BSD
@deftypevr Macro int ETIMEDOUT  @c 60 Connection timed out
The operation on a socket failed because no response was received
during the timeout period.
@end deftypevr

@comment errno.h
@comment BSD
@deftypevr Macro int ECONNREFUSED @c 61 Connection refused
A remote host refused to allow the network connection (typically because
it is not running the appropriate service).
@end deftypevr

@comment errno.h
@comment BSD
@deftypevr Macro int ELOOP      @c 62 Too many levels of symbolic links
Too many levels of symbolic links were encountered in looking up a file name.
Maybe there is a circular reference.
@end deftypevr

@comment errno.h
@comment POSIX.1
@deftypevr Macro int ENAMETOOLONG @c 63 File name too long
Filename too long (longer than @code{PATH_MAX};
@pxref{File System Parameters}).@refill
@end deftypevr

@comment errno.h
@comment BSD
@deftypevr Macro int EHOSTDOWN  @c 64 Host is down
The remote host for a network connection is down.
@end deftypevr

@comment errno.h
@comment BSD
@deftypevr Macro int EHOSTUNREACH @c 65 No route to host
The remote host for a network connection is not reachable.
@end deftypevr

@comment errno.h
@comment POSIX.1
@deftypevr Macro int ENOTEMPTY  @c 66 Directory not empty
Directory not empty, where an empty directory was expected.  Typically,
this error occurs when you are trying to remove a directory.
@end deftypevr

@comment errno.h
@comment BSD
@deftypevr Macro int EUSERS     @c 68 Too many users
The file quota system is confused because there are too many users.
@end deftypevr

@comment errno.h
@comment BSD
@deftypevr Macro int EDQUOT     @c 69 Disc quota exceeded
The user's disk quota was exceeded.
@end deftypevr

@comment errno.h
@comment BSD
@deftypevr Macro int ESTALE     @c 70 Stale NFS file handle
The NFS file handle is stale; the file on the file server has been deleted.
@end deftypevr

@comment errno.h
@comment BSD
@deftypevr Macro int EREMOTE    @c 71 Too many levels of remote in path
An attempt was made to NFS-mount a remote file system with a file name that
already specifies an NFS-mounted file.
@end deftypevr

@comment errno.h
@comment POSIX.1
@deftypevr Macro int ENOLCK     @c 77 No locks available
No locks available.  This is used by the file locking facilities;
@pxref{File Locks}.
@end deftypevr

@comment errno.h
@comment POSIX.1
@deftypevr Macro int ENOSYS     @c 78 Function not implemented
Function not implemented.  Some functions have commands or options defined
that might not be supported in all implementations, and this is the kind
of error you get if you request them and they aren't there.
@end deftypevr

@comment errno.h
@comment GNU
@deftypevr Macro int ED         @c 100 ?
The experienced user will know what is wrong.
@end deftypevr

@comment errno.h
@comment GNU
@deftypevr Macro int EGRATUITOUS @c 101 Gratuitous error
This error code has no purpose.
@end deftypevr


@node Error Messages
@section Error Messages

The library contains a couple of other useful functions to produce error
messages corresponding to values of @code{errno}.  The @code{strerror}
function, declared in @file{string.h}, returns the error message as a
string; and the @code{perror} function, declared in @file{stdio.h},
prints the error message.@refill
@pindex stdio.h
@pindex string.h

@comment string.h
@comment ANSI
@deftypefun {char *} strerror (int @var{errnum})
The @code{strerror} function maps the error code (@pxref{Error
Reporting}) specified by the @var{errnum} argument to a descriptive
error message string.  The return value is a pointer to this string.

You should not modify the string returned by @code{strerror}.  Also, if
you make subsequent calls to @code{strerror}, the string might be
overwritten.  (But it's guaranteed that no library function ever calls
@code{strerror} behind your back.)
@end deftypefun

@comment string.h
@comment ANSI
@deftypefun void perror (const char *@var{message})
This function prints an error message to the stream @code{stderr};
@pxref{Standard Streams}.

If you call @code{perror} with a @var{message} that is either a null
pointer or an empty string, @code{perror} just prints the error message 
corresponding to @code{errno}, adding a trailing newline.

If you supply a non-null @var{message} argument, then @code{perror}
prefixes its output with this string.  It adds a colon and a space 
character to separate the @var{message} from the error string corresponding
to @code{errno}.
@end deftypefun

The exact error messages used by @code{strerror} and @code{perror} vary
from system to system (but all implementations use the same set of
messages for both functions).  On the GNU system, the messages are
fairly short; there are no multi-line messages or embedded newlines.
Each error message begins with a capital letter and does not include any
terminating punctuation.

There is an example showing the use of @code{strerror} in @ref{Checking
for Errors}.

@strong{Compatibility Note:}  The @code{strerror} function is a new
feature of ANSI C.  Many older C systems do not support this function
yet.
