@node Error Reporting
@chapter Error Reporting
@cindex error reporting
@cindex reporting errors
@cindex error codes
@cindex status codes

Many functions in the GNU C Library detect and report error conditions,
and sometimes your programs need to check for these error conditions.
For example, if your program needs to open an input file, you should
make sure that the file was actually opened correctly before trying to
read from it, and print an error message or take other appropriate
action if the call to the library function failed.

This chapter describes how the error reporting facility works.  Your
program should include the header file @file{errno.h} to use this
facility.
@pindex errno.h

@menu
* Checking for Errors::	How errors are reported.
* Error Codes::		Symbolic names for error codes.
* Error Messages::	Mapping error codes onto error messages.
@end menu

@node Checking for Errors
@section Checking for Errors

Most library functions return a special value to indicate that they have
failed.  This is often a value of @code{-1}, a null pointer, or a
constant such as @code{EOF} that is defined for that purpose.  But this
a return value tells you only that an error has occurred.  To find out
what went wrong, you need to look at the error code stored in the
variable @code{errno}.  This variable is declared in the header file
@file{errno.h}.
@pindex errno.h

@comment errno.h
@comment ANSI
@deftypevr {Variable} {volatile int} errno
The variable @code{errno} contains the system error number.  You can
change the value of @code{errno}.

Since @code{errno} is declared @code{volatile}, it might be changed
asynchronously by a signal handler; @pxref{Defining a Signal Handler}.
However, a properly written signal handler saves and restores the value
of @code{errno}, so you generally do not need to worry about this
possibility in ordinary code.

The initial value of @code{errno} at program startup is zero.  Many
library functions are guaranteed to set it to certain nonzero values
when they encounter certain kinds of errors.  These error conditions are
listed for each function.  No library funciton ever stores zero in
@code{errno}.
@end deftypevr

@strong{Portability Note:} ANSI C specifies @code{errno} as a
``modifiable lvalue'' rather than as a variable, permitting it to be
implemented as a macro.  For example, its expansion might involve a
function call, like @code{*_errno ()}.  But in the GNU system,
@code{errno} really is a variable.

There are a few library functions, like @code{sqrt} and @code{atan},
that return a perfectly legitimate value in case of an error, but also
set @code{errno}.  For these functions, if you want to check to see
whether an error occurred, the recommended method is to set @code{errno}
to zero before calling the function, and then check its value afterward.

All the error codes have symbolic names, macros defined in
@file{errno.h}.  The names start with @samp{E} and an upper-case
letter or digit, and you should consider names of this form to be
reserved names.  @xref{Reserved Names}.
@pindex errno.h

The error code values are all positive integers and all distinct.
(Since the values are distinct, you can use them as labels in a
@code{switch} statement, for example.)  Your program should not make any
other assumptions about the specific values of these symbolic constants.

The value of @code{errno} doesn't necessarily have to correspond to any
of these macros, since implementations might define additional error
codes of their own for other situations.  The only values that are
guaranteed to be meaningful for a particular library function are the
ones that this manual explicitly lists for that function.

Here is an example showing how to handle failure to open a file
correctly.  The function @code{open_sesame} tries to open the named file
for reading and returns a stream if successful.  The @code{fopen}
library function returns a null pointer if it couldn't open the file for
some reason.  In that situation, this example constructs an appropriate
error message using the @code{strerror} function, and the program exits.
If we were going to make some other library calls before passing the
error code to @code{strerror}, we'd have to save it in a local variable
instead, because those other library functions might overwrite
@code{errno} in the meantime.

@example
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

extern char *program_name;

FILE *
open_sesame (char *name)
@{ 
  FILE *stream;

  errno = 0;                     
  stream = fopen (name, "r");
  if (!stream) @{
    fprintf (stderr, "%s: Couldn't open file %s; %s\n",
             program_name, name, strerror (errno));
    exit (EXIT_FAILURE);
    @}
  else
    return stream;
@}
@end example


@node Error Codes
@section Error Codes

These macros are defined in the header file @file{errno.h}.  All of
them expand into integer constant values.  Some of these error codes
can't occur on the GNU system, but they can occur using the GNU library
on other systems.
@pindex errno.h

@comment errno.h
@comment POSIX.1
@defvr Macro E2BIG
Argument list too long; used when the arguments passed to a new program
being executed with one of the @code{exec} functions (@pxref{Executing a
File}) are too large.
@end defvr

@comment errno.h
@comment POSIX.1
@defvr Macro EACCES
Permission denied; the file permissions do not allow the attempted access.
@end defvr

@comment errno.h
@comment BSD
@defvr Macro EADDRINUSE
The socket address is already in use.  @xref{Socket Naming}.
@end defvr

@comment errno.h
@comment BSD
@defvr Macro EADDRNOTAVAIL
The requested socket address is not available; for example, you tried
to give a socket a name that doesn't match the local host name.
@xref{Socket Naming}.
@end defvr

@comment errno.h
@comment BSD
@defvr Macro EAFNOSUPPORT
The address family specified for a socket is not supported; it is
inconsistent with the protocol being used on the socket.  @xref{Sockets}.
@end defvr

@comment errno.h
@comment POSIX.1
@defvr Macro EAGAIN
Resource temporarily unavailable; the call might work if you try again
later.
@end defvr

@comment errno.h
@comment BSD
@defvr Macro EALREADY
An operation is already in progress on an object that has non-blocking
mode selected.
@end defvr

@comment errno.h
@comment POSIX.1
@defvr Macro EBADF
Bad file descriptor; the file might have been closed or perhaps you are
trying to read to a file open only for writing (or vice versa).
@end defvr

@comment errno.h
@comment POSIX.1
@defvr Macro EBUSY
Resource busy; a system resource that can't be shared is already in use.
For example, if you try to delete a file that is the root of a currently
mounted filesystem, you get this error.
@end defvr

@comment errno.h
@comment POSIX.1
@defvr Macro ECHILD
There are no child processes.  This error happens on operations that are
supposed to manipulate child processes, when there aren't any processes
to manipulate.
@end defvr

@comment errno.h
@comment BSD
@defvr Macro ECONNABORTED
A network connection was aborted locally.
@end defvr

@comment errno.h
@comment BSD
@defvr Macro ECONNREFUSED
A remote host refused to allow the network connection (typically because
it is not running the appropriate service).
@end defvr

@comment errno.h
@comment BSD
@defvr Macro ECONNRESET
A network connection was closed, such as by the remote machine rebooting.
@end defvr

@comment errno.h
@comment POSIX.1
@defvr Macro EDEADLK
Deadlock avoided; allocating a system resource would have resulted in
a deadlock situation.  For an example, @xref{File Locks}.
@end defvr

@comment errno.h
@comment BSD
@defvr Macro EDESTADDRREQ
No destination address was supplied on a socket operation.
@end defvr

@comment errno.h
@comment ANSI
@defvr Macro EDOM
Domain error; used by mathematical functions when an argument value does
not fall into the domain over which the function is defined.
@end defvr

@comment errno.h
@comment BSD
@defvr Macro EDQUOT
The user's disk quota was exceeded.
@end defvr

@comment errno.h
@comment POSIX.1
@defvr Macro EEXIST
File exists; an existing file was specified in a context where it only
makes sense to specify a new file.
@end defvr

@comment errno.h
@comment POSIX.1
@defvr Macro EFAULT
Bad address; an invalid pointer was detected.
@end defvr

@comment errno.h
@comment POSIX.1
@defvr Macro EFBIG
File too big; the size of a file would be larger than allowed by the system.
@end defvr

@comment errno.h
@comment BSD
@defvr Macro EHOSTDOWN
The remote host for a network connection is down.
@end defvr

@comment errno.h
@comment BSD
@defvr Macro EHOSTUNREACH
The remote host for a network connection is not reachable.
@end defvr

@comment errno.h
@comment BSD
@defvr Macro EIDRM
A message queue identifier has been removed and is no longer valid.
@end defvr

@comment errno.h
@comment BSD
@defvr Macro EINPROGRESS
An operation that cannot complete immediately was initiated on an object
that has non-blocking mode selected.
@end defvr

@comment errno.h
@comment POSIX.1
@defvr Macro EINTR
Interrupted function call; an asynchronous signal occured and prevented
completion of the call.  When this happens, you should try the call
again.
@end defvr

@comment errno.h
@comment POSIX.1
@defvr Macro EINVAL
Invalid argument.  This is used to indicate various kinds of problems
with passing the wrong argument to a library function.
@end defvr

@comment errno.h
@comment POSIX.1
@defvr Macro EIO
Input/output error; usually used for physical read or write errors.
@end defvr

@comment errno.h
@comment BSD
@defvr Macro EISCONN
You tried to connect a socket that is already connected.
@xref{Establishing a Connection}.
@end defvr

@comment errno.h
@comment POSIX.1
@defvr Macro EISDIR
File is a directory; it can't be written to like an ordinary file.
@end defvr

@comment errno.h
@comment BSD
@defvr Macro ELOOP
Too many levels of symbolic links were encountered in looking up a file name.
Maybe there is a circular reference.
@end defvr

@comment errno.h
@comment POSIX.1
@defvr Macro EMFILE
The process has too many files open and can't open any more.
@end defvr

@comment errno.h
@comment POSIX.1
@defvr Macro EMLINK
Too many links; the link count of a single file is too large.
@end defvr

@comment errno.h
@comment BSD
@defvr Macro EMSGSIZE
The size of a message sent on a socket was larger than the supported
maximum size.  
@end defvr

@comment errno.h
@comment POSIX.1
@defvr Macro ENAMETOOLONG
Filename too long.  
@end defvr

@comment errno.h
@comment BSD
@defvr Macro ENETDOWN
A socket operation failed because the network was down.
@end defvr

@comment errno.h
@comment BSD
@defvr Macro ENETRESET
The network connection was reset because the remote host crashed.
@end defvr

@comment errno.h
@comment BSD
@defvr Macro ENETUNREACH
A socket operation failed because the network was unreachable.
@end defvr

@comment errno.h
@comment POSIX.1
@defvr Macro ENFILE
There are too many files open in the entire system.
@end defvr

@comment errno.h
@comment BSD
@defvr Macro ENOBUFS
No internal buffer space available for an operation on a pipe or socket.
@end defvr

@comment errno.h
@comment POSIX.1
@defvr Macro ENODEV
No such device.  This a ``file doesn't exist'' error, but is
used only when the file is expected to represent a device, like a
block special file for a disk.
@end defvr

@comment errno.h
@comment POSIX.1
@defvr Macro ENOENT
No such file or directory.  This is a ``file doesn't exist'' error
for ordinary files that are referenced in contexts where they are
expected to already exist.
@end defvr

@comment errno.h
@comment POSIX.1
@defvr Macro ENOEXEC
Invalid executable file format.  This condition is detected by the
@code{exec} functions; @pxref{Executing a File}.
@end defvr

@comment errno.h
@comment POSIX.1
@defvr Macro ENOLCK
No locks available.  This is used by the file locking facilities;
@pxref{File Locks}.
@end defvr

@comment errno.h
@comment POSIX.1
@defvr Macro ENOMEM
Not enough memory available.
@end defvr

@comment errno.h
@comment BSD
@defvr Macro ENOMSG
There is no message of the specified type available immediately, and
blocking was not desired.
@end defvr

@comment errno.h
@comment BSD
@defvr Macro ENOPROTOOPT
You specified a socket option that doesn't make sense for the
particular protocol being used by the socket.  @xref{Socket Options}.
@end defvr

@comment errno.h
@comment POSIX.1
@defvr Macro ENOSPC
No space left on device; write operation on a file failed because the
device is full.
@end defvr

@comment errno.h
@comment POSIX.1
@defvr Macro ENOSYS
Function not implemented.  Some functions have commands or options defined
that might not be supported in all implementations, and this is the kind
of error you get if you request them and they aren't there.
@end defvr

@comment errno.h
@comment BSD
@defvr Macro ENOTBLK
A file that isn't a block special file was given in a situation that
requires one.  For example, trying to mount an ordinary file as a file
system will give this error.
@end defvr

@comment errno.h
@comment BSD
@defvr Macro ENOTCONN
The socket is not connected to anything.  You get this message when you
try to transmit data over a socket, without first specifying a destination
for the data.
@end defvr

@comment errno.h
@comment POSIX.1
@defvr Macro ENOTDIR
A file that isn't a directory was given in a situation that requires
one.
@end defvr

@comment errno.h
@comment BSD
@defvr Macro ENOTSOCK
A file that isn't a socket was given in a situation that requires one.
@end defvr

@comment errno.h
@comment POSIX.1
@defvr Macro ENOTEMPTY
Directory not empty, where an empty directory was expected.  Typically,
this error occurs when you are trying to remove a directory.
@end defvr

@comment errno.h
@comment POSIX.1
@defvr Macro ENOTTY
Inappropriate I/O control operation, such as trying to set terminal
modes on an ordinary file.
@end defvr

@comment errno.h
@comment POSIX.1
@defvr Macro ENXIO
No such device or address.  Typically, this means that a file
representing a device has been installed incorrectly, and the
system can't find the right kind of device driver for it.
@end defvr

@comment errno.h
@comment BSD
@defvr Macro EOPNOTSUPP
The socket operation you requested is not supported.  Some socket functions
don't make sense for all types of sockets, and others may not be implemented
for all communications protocols.
@end defvr

@comment errno.h
@comment POSIX.1
@defvr Macro EPERM
Operation not permitted; only the owner of the file (or other resource)
or processes with special privileges can perform the operation.
@end defvr

@comment errno.h
@comment BSD
@defvr Macro EPFNOSUPPORT
The socket communications protocol family you requested is not supported.
@end defvr

@comment errno.h
@comment POSIX.1
@defvr Macro EPIPE
Broken pipe; there is no process reading from the other end of a pipe.
@end defvr

@comment errno.h
@comment BSD
@defvr Macro EPROTONOSUPPORT
The socket domain does not support the requested communications protocol.
@xref{Creating a Socket}.
@end defvr

@comment errno.h
@comment BSD
@defvr Macro EPROTOTYPE
The socket type does not support the requested communications protocol.
@end defvr

@comment errno.h
@comment ANSI
@defvr Macro ERANGE
Range error; used by mathematical functions when the result value is
not representable because of overflow or underflow.
@end defvr

@comment errno.h
@comment BSD
@defvr Macro EREMOTE
An attempt was made to NFS-mount a remote file system with a file name that
already specifies an NFS-mounted file.
@end defvr

@comment errno.h
@comment POSIX.1
@defvr Macro EROFS
An attempt was made to modify a file on a read-only file system.
@end defvr

@comment errno.h
@comment BSD
@defvr Macro ESHUTDOWN
The socket has already been shut down.
@end defvr

@comment errno.h
@comment BSD
@defvr Macro ESOCKTNOSUPPORT
The socket type is not supported.
@end defvr

@comment errno.h
@comment POSIX.1
@defvr Macro ESPIPE
Invalid seek operation (such as on a pipe).
@end defvr

@comment errno.h
@comment POSIX.1
@defvr Macro ESRCH
There is no such process that matches the specified process ID.
@end defvr

@comment errno.h
@comment BSD
@defvr Macro ESTALE
The NFS file handle is stale; the file on the file server has been deleted.
@end defvr

@comment errno.h
@comment BSD
@defvr Macro ETIMEDOUT
The operation on a socket failed because no response was received
during the timeout period.
@end defvr

@comment errno.h
@comment BSD
@defvr Macro ETXTBSY
An attempt to execute a file that is currently open for writing, or
write to a file that is currently being executed.  (The name stands
for ``text file busy''.)
@end defvr

@comment errno.h
@comment BSD
@defvr Macro EUSERS
The file quota system is confused because there are too many users.
@end defvr

@comment errno.h
@comment BSD
@defvr Macro EWOULDBLOCK
An operation that would block was attempted on an object that has
non-blocking mode selected.
@end defvr

@comment errno.h
@comment POSIX.1
@defvr Macro EXDEV
An attempt to make an improper link across file systems was detected.
@end defvr


@node Error Messages
@section Error Messages

The library contains a couple of other useful functions to produce error
messages corresponding to values of @code{errno}.  The @code{strerror}
function, declared in @file{string.h}, returns the error message as a
string; and the @code{perror} function, declared in @file{stdio.h},
prints the error message.@refill
@pindex stdio.h
@pindex string.h

@comment string.h
@comment ANSI
@deftypefun {char *} strerror (int @var{errnum})
The @code{strerror} function maps the error code (@pxref{Error
Reporting}) specified by the @var{errnum} argument to a descriptive
error message string.  The return value is a pointer to this string.

You should not modify the string returned by @code{strerror}.  Also, if
you make subsequent calls to @code{strerror}, the string might be
overwritten.  (But it's guaranteed that no library function ever calls
@code{strerror} behind your back.)
@end deftypefun

@comment string.h
@comment ANSI
@deftypefun void perror (const char *@var{message})
This function prints an error message to the stream @code{stderr};
@pxref{Standard Streams}.

If you call @code{perror} with a @var{message} that is either a null
pointer or an empty string, @code{perror} just prints the error message 
corresponding to @code{errno}, adding a trailing newline.

If you supply a non-null @var{message} argument, then @code{perror}
prefixes its output with this string.  It adds a colon and a space 
character to separate the @var{message} from the error string corresponding
to @code{errno}.
@end deftypefun

The exact error messages used by @code{strerror} and @code{perror} vary
from system to system (but all implementations use the same set of
messages for both functions).  On the GNU system, the messages are
fairly short; there are no multi-line messages or embedded newlines.
Each error message begins with a capital letter and does not include any
terminating punctuation.

There is an example showing the use of @code{strerror} in @ref{Checking
for Errors}.

@strong{Compatibility Note:}  The @code{strerror} function is a new
feature of ANSI C.  Many older C systems do not support this function
yet.
