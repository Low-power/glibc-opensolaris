@node Low-Level Input/Output
@chapter Low-Level Input/Output

This chapter describes functions for performing low-level input/output
operations on file descriptors.  These functions include the primitives for
the higher-level i/o functions described in @ref{Input/Output on
Streams}, as well as functions for performing low-level control operations
for which there are no equivalents on streams.

@menu
* File Descriptors and Streams::	How the low-level facilities described
					 here interact with the high-level
					 I/O facilities.
* Opening and Closing Files::		How to open and close file descriptors.
* Input and Output Primitives::		Reading, writing, and seeking 
					 operations.
* Control Operations on Files::		Various other operations on file
					 descriptors.
@end menu

@node File Descriptors and Streams
@section File Descriptors and Streams

The functions described in this chapter deal with open files by means of
integer file descriptors.  These are distinct from streams.  Streams are
implemented in terms of file descriptors, but include additional
information to support things like buffering of input and output, and
error and end-of-file indicators.  A file descriptor is much more
primitive than a stream, and has none of this associated state
information.

You can make a new stream from a file descriptor with the @code{fdopen}
function, and get the underlying file descriptor for an existing stream
with the @code{fileno} function.  These functions are declared in the
header file @file{<stdio.h>}.

@comment stdio.h
@comment POSIX.1
@deftypefun {FILE *} fdopen (int @var{filedes}, const char *@var{opentype})
The @code{fdopen} function returns a new stream for the file descriptor
@var{filedes}.

The @var{opentype} argument is interpreted in the same way as for the
@code{fopen} function (@pxref{Opening and Closing Streams}), except that
the @samp{b} option is not permitted; this is because GNU makes no
distinction between text and binary files.  Also, @code{"w"} and
@code{"w+"} do not cause truncation of the file; these have affect only
when opening a file, and in this case the file has already been opened.
You must make sure that the @var{opentype} argument matches the actual
mode of the open file descriptor.

The return value is the new stream.  If the stream cannot be created
(for example, if the modes for the file indicated by the file descriptor
do not permit the access specified by the @var{opentype} argument), a
null pointer is returned instead.
@end deftypefun

For an example showing the use of the @code{fdopen} function,
@pxref{Creating a Pipe}.

@comment stdio.h
@comment POSIX.1
@deftypefun int fileno (FILE *@var{stream})
This function returns the file descriptor associated with the stream
@var{stream}.  If an error is detected (for example, if the @var{stream}
is not valid), @code{-1} is returned instead.
@end deftypefun

@cindex standard file descriptors
There are also symbolic constants defined in @file{<unistd.h>} for the
file descriptors belonging to the standard streams @code{stdin},
@code{stdout}, and @code{stderr}; @pxref{Standard Streams}.

@comment unistd.h
@comment POSIX.1
@defvr Macro STDIN_FILENO
This macro has value @code{0}, which is the file descriptor for
standard input.
@end defvr

@comment unistd.h
@comment POSIX.1
@defvr Macro STDOUT_FILENO
This macro has value @code{1}, which is the file descriptor for
standard output.
@end defvr

@comment unistd.h
@comment POSIX.1
@defvr Macro STDERR_FILENO
This macro has value @code{2}, which is the file descriptor for
standard error output.
@end defvr

Because you can have multiple file descriptors and streams pointing to
the same open file, you have to be very careful about mixing operations
on them.  

The exact rules for mixing operations on streams and file descriptors
for the same open file are complicated (you can read the POSIX.1 standard
to find out about them), but the general idea is that you must make sure
that any buffered input or output to a stream has been flushed before
you start to do further i/o operations on the same open file by means of
another file descriptor or stream.  And, you should also be aware that
changing the file position of a file descriptor or stream can confuse
other file descriptors and streams pointing to the same open file.

It's best not to try to interleave input and output operations on file
descriptors and streams pointing to the same open file at all.  For
example, if you want to open a pipe (something you can only do at the
file descriptor level) but otherwise treat the pipe like an ordinary
file, you should use @code{fdopen} to create a stream and do all
subsequent i/o operations on the stream instead of on the file
descriptor.  If you want to change the input modes on a terminal device
so that it does something nonstandard like single-character input
without echo (@pxref{Terminal Modes}, for information on how to do
this), then you should use the low-level i/o primitives on the file
descriptor instead of trying to treat it as a stream.

@node Opening and Closing Files
@section Opening and Closing Files

This section describes the primitives for opening and closing files
using file descriptors.  The @code{open} and @code{creat} functions are
declared in the header file @file{<fcntl.h>}, while @code{close} is
declared in @file{<unistd.h>}.

@comment fcntl.h
@comment POSIX.1
@deftypefun int open (const char *@var{filename}, int @var{flags}, @dots{})
The @code{open} function creates and returns a new file descriptor
for the file named by @var{filename}.  Initially, the file position
indicator for the file is at the beginning of the file.

The @var{flags} argument controls how the file is to be opened.
This is formed from the bitwise OR of the appropriate parameters.

The @var{flags} argument must include exactly one of these values to
specify the file access mode:

@table @code
@item O_RDONLY
Open the file for read access.

@item O_WRONLY
Open the file for write access.

@item O_RDWR
Open the file for both reading and writing.
@end table

The @var{flags} argument can also include any combination of these
flags:

@table @code
@item O_APPEND
If set, writing can be performed only at the end of the file.

@item O_CREAT
If the file doesn't exist, create it.  This option requires a third
argument, @var{mode}, of type @code{mode_t}, to be supplied; 
@pxref{Assigning File Permissions}.

@item O_EXCL
If both @code{O_CREAT} and @code{O_EXCL} are set, then @code{open}
fails if the file already exists.

@item O_NOCTTY
If the @var{filename} names a terminal device, don't make it the
controlling terminal for the process.  @xref{Job Control}, for
information about what it means to be the controlling terminal.

@item O_NONBLOCK
This sets nonblocking mode.  This option is usually only useful for
special files such as FIFOs (@pxref{Pipes and FIFOs}) and devices such
as terminals.  Normally, for these files, @code{open} blocks until
the file is ``ready''.  If @code{O_NONBLOCK} is set, @code{open}
returns immediately.

@item O_TRUNC
If the file exists and is opened for write access, truncate it to zero
length.  This option is only useful for regular files, not special
files such as directories or FIFOs.
@end table

For more information about these symbolic constants, @pxref{File Status
Flags}.

The normal return value from @code{open} is a non-negative integer file
descriptor.  In the case of an error, a value of @code{-1} is returned
instead.  In addition to the usual file name syntax errors (@pxref{File
Name Errors}), the following @code{errno} error conditions are defined
for this function:

@table @code
@item EACCES
The file exists but is not readable/writable as requested by the @var{flags}
argument.

@item EEXIST
Both @code{O_CREAT} and @code{O_EXCL} are set, and the named file already
exists.

@item EINTR
The operation was interrupted by a signal.

@item EISDIR
The @var{flags} argument specified write access, and the file is a directory.

@item EMFILE
The process has too many files open.

@item ENFILE
The system has too many files open.

@item ENOENT
The named file does not exist, but @code{O_CREAT} is not specified.

@item ENOSPC
The directory or file system that would contain the new file cannot be
extended.

@item ENXIO
@code{O_NONBLOCK} and @code{O_WRONLY} are both set in the @var{flags}
argument, the file named by @var{filename} is a FIFO (@pxref{Pipes and
FIFOs}), and no process has the file open for reading.

@item EROFS
The file resides on a read-only file system and any of @code{O_WRONLY},
@code{O_RDWR}, @code{O_CREAT}, and @code{O_TRUNC} are set in the
@var{flags} argument.
@end table

The @code{open} function is the underlying primitive for the @code{fopen}
and @code{freopen} functions, that create streams.
@end deftypefun

@comment fcntl.h
@comment POSIX.1
@deftypefun int creat (const char *@var{filename}, mode_t @var{mode})
This function is obsolete.  The call

@example
creat (@var{filename}, @var{mode})
@end example

@noindent
is equivalent to

@example
open (@var{filename}, O_WRONLY | O_CREAT | O_TRUNC, @var{mode})
@end example
@end deftypefun

@comment unistd.h
@comment POSIX.1
@deftypefun int close (int @var{filedes})
The function @code{close} closes the file descriptor @var{filedes}.
Closing a file has the following consequences:

@itemize @bullet
@item 
The file descriptor is deallocated.

@item
Any record locks owned by the process on the file are unlocked.

@item
When all file descriptors associated with a pipe or FIFO have been closed,
any unread data is discarded.
@end itemize

The normal return value from @code{close} is @code{0}; a value of @code{-1}
is returned in case of failure.  The following @code{errno} error
conditions are defined for this function:

@table @code
@item EBADF
The @var{filedes} argument is not a valid file descriptor.

@item EINTR
The call was interrupted by a signal.
@end table
@end deftypefun

To close a stream, you should call @code{fclose} (@pxref{Opening and
Closing Streams}) instead of trying to close its underlying file
descriptor with @code{close}.  This makes sure that the stream is
closed cleanly, and that any buffered output associated with the stream
is flushed.


@node Input and Output Primitives
@section Input and Output Primitives

This section describes the functions for performing primitive input and
output operations on file descriptors: @code{read}, @code{write}, and
@code{lseek}.  These functions are declared in the header file
@file{<unistd.h>}.

@comment unistd.h
@comment POSIX.1
@deftp {Data Type} ssize_t
This data type is used to represent the sizes of blocks that can be
read or written in a single operation.  It is similar to @code{size_t},
but must be a signed type.
@end deftp

@comment unistd.h
@comment POSIX.1
@deftypefun ssize_t read (int @var{filedes}, void *@var{buffer}, size_t @var{size})
The @code{read} function reads up to @var{size} bytes from the file
with descriptor @var{filedes}, storing the results in the @var{buffer}.
(This is not necessarily a character string and there is no terminating
null character added.)

The number of bytes actually read is returned.  This might be less than
@var{size}; for example, if there aren't that many bytes left in the
file or if there aren't that many bytes immediately available.
The exact behavior depends on what kind of file it is.  A value of zero
indicates end-of-file (except if the value of the @var{size} argument
is also zero).

In case of an error, @code{read} returns @code{-1}.  The following
@code{errno} error conditions are defined for this function:

@table @code
@item EAGAIN
Normally, @code{read} blocks if there is no input immediately available
on the file.  But if the @code{O_NONBLOCK} flag is set for the file
(@pxref{File Status Flags}), it returns immediately without
reading any data, and reports this error.

@item EBADF
The @var{filedes} argument is not a valid file descriptor.

@item EINTR
The read operation was interrupted by a signal while it was blocked
waiting for input.

@item EIO
This error is reported when a background process tries to read from the
controlling terminal, and the normal action of stopping the process by
sending it a @code{SIGTTIN} signal isn't working.  This might happen if
signal is being blocked or ignored, or because the process group is
orphaned).  @xref{Job Control}, for more information about job control,
and @ref{Signal Handling}, for information about signals.
@end table

The @code{read} function is the underlying primitive for all of the
functions that read from streams, such as @code{fgetc}.
@end deftypefun

@comment unistd.h
@comment POSIX.1
@deftypefun ssize_t write (int @var{filedes}, const void *@var{buffer}, size_t @var{size})
The @code{write} function writes up to @var{size} bytes from
@var{buffer} to the file with descriptor @var{filedes}.  The
@var{buffer} is not necessarily a character string and a null character
is not used as a terminator.

The number of bytes actually written is returned.  This is normally the
same as @var{size}, but might be less (for example, if the physical
media being written to fills up).  

In the case of an error, @code{write} returns @code{-1}.  The following
@code{errno} error conditions are defined for this function:

@table @code
@item EAGAIN
Normally, @code{write} blocks until the write operation is complete.
But if the @code{O_NONBLOCK} flag is set for the file (@pxref{Control
Operations on Files}), it returns immediately without writing any data,
and reports this error.  An example of a situation that might cause the
process to block on output is writing to a terminal device that supports
flow control, where output has been suspended by receipt of a STOP
character.

@item EBADF
The @var{filedes} argument is not a valid file descriptor.

@item EFBIG
The size of the file is larger than the implementation can support.

@item EINTR
The write operation was interrupted by a signal while it was blocked
waiting for completion.

@item EIO
This error is reported when a background process tries to write to the
controlling terminal, and the normal action of stopping the process by
sending it a @code{SIGTTOU} signal isn't working.  This might happen if
the signal is being blocked or ignored.  @xref{Job Control}, for more
information about job control, and @ref{Signal Handling}, for
information about signals.

@item ENOSPC
The device is full.

@item EPIPE
This error is returned when you try to write to a pipe or FIFO that
isn't open for reading by any process.  When this happens, a @code{SIGPIPE}
signal is also sent to the process; @pxref{Signal Handling}.
@end table

The @code{write} function is the underlying primitive for all of the
functions that write to streams, such as @code{fputc}.
@end deftypefun

@strong{Incomplete:} The POSIX.1 document goes into a lot of verbiage here
about writing to a pipe and the interaction with the @code{O_NONBLOCK} 
flag and the @code{PIPE_BUF} parameter.  Is this really important?

@comment sys/types.h
@comment POSIX.1
@deftp {Data Type} off_t
This is an arithmetic data type used to represent file sizes.
In the GNU system, this is equivalent to @code{fpos_t} or @code{long int}.
@end deftp

@comment unistd.h
@comment POSIX.1
@deftypefun off_t lseek (int @var{filedes}, off_t @var{offset}, int @var{whence})
The @code{lseek} function is used to change the file position of the
file with descriptor @var{filedes}.  This is similar to the @code{fseek}
function (@pxref{File Positioning}), but operates on a file descriptor
rather than a stream.  The @var{whence} argument specifies how the
@var{offset} should be interpreted in the same way as for the
@code{fseek} function, and can be one of the symbolic constants
@code{SEEK_SET}, @code{SEEK_CUR}, or @code{SEEK_END}.

The return value from @code{lseek} is normally the resulting file
position, measured in bytes from the beginning of the file.

If the file positioning operation fails, @code{lseek} returns a value of
@code{(off_t)(-1)}.  The following @code{errno} error conditions are
defined for this function:

@table @code
@item EBADF
The @var{filedes} is not a valid file descriptor.

@item EINVAL
The @var{whence} argument value is not valid, or the resulting
file offset is not valid.

@item ESPIPE
The @var{filedes} corresponds to a pipe or FIFO, which cannot be positioned.
(There may be other kinds of files that cannot be positioned either, but
the behavior is not specified in those cases.)
@end table

The @code{lseek} function is the underlying primitive for the
@code{fseek}, @code{ftell} and @code{rewind} functions, which operate on
streams instead of file descriptors.
@end deftypefun


@node Control Operations on Files
@section Control Operations on Files

This section describes how you can perform various other operations on
file descriptors, such as inquiring about or setting flags describing
the status of the file descriptor, manipulating record locks, and the
like.  All of these operations are performed by the function @code{fcntl}.

@menu
* File Control Operations Summary::	About the @code{fcntl} function.
* Redirecting Input and Output::	Fcntl commands for duplicating file
					 descriptors.
* File Descriptor Flags::		Fcntl commands for manipulating flags
					 associated with file descriptors.
* File Status Flags::			Fcntl commands for manipulating flags
					 associated with open files.
* File Locks::				Fcntl commands for implementing file
					 locking.
* Other File Control Commands::		Miscellaneous commands.
@end menu

@node File Control Operations Summary
@subsection File Control Operations Summary

The second argument to the @code{fcntl} function is a command that
specifies which operation to perform.  The function and macros that name
various flags that are used with it are declared in the header file
@file{<fcntl.h>}.  (Many of these flags are also used by the @code{open}
function; @pxref{Opening and Closing Files}.)

@comment fcntl.h
@comment POSIX.1
@deftypefun int fcntl (int @var{filedes}, int @var{command}, @dots{})
The @code{fcntl} function performs the operation specified by
@var{command} on the file descriptor @var{filedes}.  Some commands
require additional arguments to be supplied.  These additional arguments
and the return value and error conditions are given in the detailed
descriptions of the individual commands.

Briefly, here is a list of what the various commands are.

@table @code
@item F_DUPFD
Duplicate the file descriptor (return another file descriptor pointing
to the same open file).  @xref{Redirecting Input and Output}.

@item F_GETFD
Get flags associated with the file descriptor.  @xref{File Descriptor Flags}.

@item F_SETFD
Set flags associated with the file descriptor.  @xref{File Descriptor Flags}.

@item F_GETFL
Get flags associated with the open file.  @xref{File Status Flags}.

@item F_SETFL
Set flags associated with the open file.  @xref{File Status Flags}.

@item F_GETLK
Get a file lock.  @xref{File Locks}.

@item F_SETLK
Set or clear a file lock.  @xref{File Locks}.

@item F_SETLKW
Like @code{F_SETLK}, but wait for completion.  @xref{File Locks}.

@item F_GETOWN
Get process or process group ID to receive @code{SIGIO} signals.
@xref{Other File Control Commands}.

@item F_SETOWN
Set process or process group ID to receive @code{SIGIO} signals.
@xref{Other File Control Commands}.
@end table
@end deftypefun


@node Redirecting Input and Output
@subsection Redirecting Input and Output

@cindex redirecting input and output
The major use of duplicating a file descriptor is to implement
@dfn{redirection} of input or output:  that is, to change the
file or pipe that a file descriptor corresponds to.

You can perform this operation using the @code{fcntl} function with the
@code{F_DUPFD} command, but there are also specialized functions
@code{dup} and @code{dup2} to do the same operation.  

The @code{fcntl} function and flags are declared in @file{<fcntl.h>},
while prototypes for @code{dup} and @code{dup2} are in the header file
@file{<unistd.h>}.

@comment fcntl.h
@comment POSIX.1
@defvr Macro F_DUPFD
This macro is used as the @var{command} argument to @code{fcntl}, to
specify that it should @dfn{duplicate} the file descriptor received as the
first argument.  The new file descriptor refers to the same open file,
but can have its own set of file descriptor flags.
@cindex duplicating a file descriptor

The form of the call in this case is:

@example
fcntl (@var{filedes}, F_DUPFD, @var{next_filedes})
@end example

The @var{next_filedes} argument is of type @code{int} and specifies that
the file descriptor returned should be the next available one greater
than or equal to this value.

The return value from @code{fcntl} with this command is normally the value
of the new file descriptor.  A return value of @code{-1} indicates an
error.  The following @code{errno} error conditions are defined for
this command:

@table @code
@item EBADF
The @var{filedes} argument is invalid.

@item EINVAL
The @var{next_filedes} argument is invalid.

@item EMFILE
There are no more file descriptors available.
@end table
@end defvr

@comment unistd.h
@comment POSIX.1
@deftypefun int dup (int @var{filedes})
This function is equivalent to @code{fcntl (@var{filedes}, F_DUPFD, 0)}.
@end deftypefun

@comment unistd.h
@comment POSIX.1
@deftypefun int dup2 (int @var{filedes}, int @var{old_filedes})
The call:

@example
dup2 (@var{filedes}, @var{old_filedes})
@end example

@noindent
is equivalent to:

@example
close (@var{old_filedes});
fcntl (@var{filedes}, F_DUPFD, @var{old_filedes})
@end example

In other words, the file previously associated with @var{old_filedes} is
closed, and the descriptor is reassigned to point to the same open file
as @var{filedes}.
@end deftypefun

Here is an example showing how to use @code{dup2} to do redirection.
Typically, redirection of the standard streams (like @code{stdin}) is
done by a shell or shell-like program before calling one of the
@code{exec} functions (@pxref{Executing a File}) to execute a new
program in a child process.  When the new program is executed, it
creates and initializes the standard streams to point to the
corresponding file descriptors, before its @code{main} function is
invoked.

So, to redirect standard input to a file, the shell could do something
like:

@example
char *filename;
char *program;
int file;
@dots{}
file = open (filename, O_RDONLY);
dup2 (file, STDIN_FILENO);
execv (program, NULL);
@end example

There is also a more detailed example showing how to implement redirection
in the context of a pipeline of processes in @ref{Launching Jobs}.


@node File Descriptor Flags
@subsection File Descriptor Flags

@dfn{File descriptor flags} are miscellaneous attributes of a file
descriptor.  These flags are associated with particular file
descriptors, so that if you have created duplicate file descriptors
pointing to the same open file, each descriptor has its own set of flags.
@cindex file descriptor flags

These flags for the @code{fcntl} function are defined in the header
file @file{<fcntl.h>}.

@comment fcntl.h
@comment POSIX.1
@defvr Macro F_GETFD
This macro is used as the @var{command} argument to @code{fcntl}, to
specify that it should return the file descriptor flags associated
with the @var{filedes} argument.  

The normal return value from @code{fcntl} with this command is a
nonnegative number which can be interpreted as the bitwise OR of the
individual flags.  The only flag currently defined is @code{FD_CLOEXEC}
(close on @code{exec}).

In case of an error, @code{fcntl} returns @code{-1}.  The following
@code{errno} error conditions are defined for this command:

@table @code
@item EBADF
The @var{filedes} argument is invalid.
@end table
@end defvr


@comment fcntl.h
@comment POSIX.1
@defvr Macro F_SETFD
This macro is used as the @var{command} argument to @code{fcntl}, to
specify that it should set the file descriptor flags associated with the
@var{filedes} argument.  This requires a third @code{int} argument to
specify the new flags, so the form of the call is:

@example
fcntl (@var{filedes}, F_SETFD, @var{new_flags})
@end example

The normal return value from @code{fcntl} with this command is an
unspecified value other than @code{-1}, which indicates an error.
The flags and error conditions are the same as for the @code{F_GETFD}
command.
@end defvr

The following macro is defined for use as a file descriptor flag with
the @code{fcntl} function.  The value is an integer constant usable
as a bit mask value.

@comment fcntl.h
@comment POSIX.1
@defvr Macro FD_CLOEXEC
This flag specifies that the file descriptor should be closed when
an @code{exec} function is invoked; @pxref{Executing a File}.  When
a file descriptor is allocated (as with @code{open} or @code{dup}),
this bit is initially cleared on the new file descriptor.
@end defvr

If you want to modify the file descriptor flags, you should get the
current flags with @code{F_GETFD} and modify the value.  Don't assume
that the flags listed here are the only ones that are implemented.


@node File Status Flags
@subsection File Status Flags

@dfn{File status flags} are used to specify more attributes of an open
file descriptor.  Unlike the file descriptor flags discussed in
@ref{File Descriptor Flags}, the file status flags are shared by
duplicated file descriptors pointing to the open file.
@cindex file status flags

These flags for the @code{fcntl} function are defined in the header
file @file{<fcntl.h>}.

@comment fcntl.h
@comment POSIX.1
@defvr Macro F_GETFL
This macro is used as the @var{command} argument to @code{fcntl}, to
specify that it should return the file status flags for the open file
with descriptor @var{filedes}.

The normal return value from @code{fcntl} with this command is a
nonnegative number which can be interpreted as the bitwise OR of the
individual flags.  The flags are encoded like the @var{flags} argument
to @code{open} (@pxref{Opening and Closing Files}), but only the file
access modes and the @code{O_APPEND} and @code{O_NONBLOCK} flags are
meaningful here.  Since the file access modes are not single-bit values,
you can mask off other bits in the returned flags with @code{O_ACCMODE}
to compare them.

In case of an error, @code{fcntl} returns @code{-1}.  The following
@code{errno} error conditions are defined for this command:

@table @code
@item EBADF
The @var{filedes} argument is invalid.
@end table
@end defvr

@comment fcntl.h
@comment POSIX.1
@defvr Macro F_SETFL
This macro is used as the @var{command} argument to @code{fcntl}, to
specify that it should set the file status flags for the open
file corresponding to the @var{filedes} argument.  This command requires
a third @code{int} argument to specify the new flags, so the form of
the call is

@example
fcntl (@var{filedes}, F_SETFL, @var{new_flags})
@end example

You can't change the access mode for the file in this way; that is,
whether the file descriptor was opened for reading or writing.  You can
only change the @code{O_APPEND} and @code{O_NONBLOCK} flags.

The normal return value from @code{fcntl} with this command is an
unspecified value other than @code{-1}, which indicates an error.  The
error conditions are the same as for the @code{F_GETFL} command.
@end defvr

The following macros are defined for use as file status flags with the
@code{fcntl} and @code{open} functions:

@comment fcntl.h
@comment POSIX.1
@defvr Macro O_CREAT
This macro is usable as a flag to @code{open} only.  It expands into a
bit mask value; if this bit is set, it specifies that the file should be
created if it doesn't already exist.
@end defvr

@comment fcntl.h
@comment POSIX.1
@defvr Macro O_EXCL
This macro is usable as a flag to @code{open} only.  It's a bit mask
value that specifies exclusive use of the new file.  If this bit is set
and the file already exists, @code{open} reports an error.
@end defvr

@comment fcntl.h
@comment POSIX.1
@defvr Macro O_NOCTTY
This macro is usable as a flag to @code{open} only.  If this bit is set,
it prevents the new file from becoming the controlling terminal of the
process that opens it.
@end defvr

@comment fcntl.h
@comment POSIX.1
@defvr Macro O_TRUNC
This macro is usable as a flag to @code{open} only.  If this bit is set,
the old contents of an existing file are discarded when the file is
opened.  If this bit isn't set, then parts of the file that aren't
explicitly overwritten remain in place with their original contents
intact.
@end defvr

@comment fcntl.h
@comment POSIX.1
@defvr Macro O_APPEND
This macro is a bit mask value that specifies append mode for the file.
If this bit is set, then writing happens at the end of the file only.
You can use this flag with both @code{open} and @code{fcntl}.
@end defvr

@comment fcntl.h
@comment POSIX.1
@defvr Macro O_NONBLOCK
This macro is a bit mask value that specifies nonblocking mode for the
file.  If this bit is set, this permits @code{read} requests on the file
to return immediately with a failure status if there is no input
immediately available, instead of blocking.  Likewise, @code{write}
requests can also return immediately with a failure status if the output
can't be written immediately.  You can use this flag with both
@code{open} and @code{fcntl}.
@end defvr

@comment fcntl.h
@comment BSD
@defvr Macro O_NDELAY
This is a synonym for @code{O_NONBLOCK}, provided for compatibility with
BSD.
@end defvr

@comment fcntl.h
@comment POSIX.1
@defvr Macro O_ACCMODE
The value of this macro is a mask that can be bitwise-ANDed with the
file status flag value to produce a value representing the file access
mode.
@end defvr

@comment fcntl.h
@comment POSIX.1
@defvr Macro O_RDONLY
This macro expands into a value that indicates the file is open for
read access only.
@end defvr

@comment fcntl.h
@comment POSIX.1
@defvr Macro O_WRONLY
This macro expands into a value that indicates the file is open for
write access only.
@end defvr

@comment fcntl.h
@comment POSIX.1
@defvr Macro O_RDWR
This macro expands into a value that indicates the file is open for
both read and write access.
@end defvr

@strong{Incomplete:} @file{<fcntl.h>} also contains defines for
@code{FREAD}, @code{FWRITE}, etc.  Mib says: ``Those are internal flags
in the kernel.  They won't exist in the GNU system.''

If you want to modify the file status flags, you should get the current
flags with @code{F_GETFL} and modify the value.  Don't assume that the
flags listed here are the only ones that are implemented.

@node File Locks
@subsection File Locks

@cindex file locks
@cindex record locking
The remaining @code{fcntl} commands are used to support @dfn{record
locking}, a way to prevent multiple processes from simultaneously
accessing parts of a file in incompatible ways.

@cindex exclusive lock
@cindex write lock
An @dfn{exclusive} or @dfn{write} lock gives a process exclusive access
for writing to the specified part of the file.  While a write lock is in
place, no other process can lock that part of the file.

@cindex shared lock
@cindex read lock
A @dfn{shared} or @dfn{read} lock prohibits any other process from
requesting a write lock on the specified part of the file.  However,
other processes can request read locks.

The @code{read} and @code{write} functions do not actually check to see
whether there are any locks in place.  If you want to implement a
locking protocol for a file shared by multiple processes, your application
must do explicit @code{fcntl} calls to request and clear locks at the
appropriate points.

Locks are associated with processes.  A process can only have one kind
of lock set for each byte of the same file.  When any file descriptor
for that file is closed by the process, all of the locks that process
holds on that file are released.  Likewise, locks are released when a
process exits, and are not inherited by child processes created using
@code{fork} (@pxref{Creating a Process}).

Locks are specified using a @code{flock} structure.  This data type
and the associated macros for the @code{fcntl} function are declared
in the header file @file{<fcntl.h>}.

@comment fcntl.h
@comment POSIX.1
@deftp {Data Type} {struct flock}
This structure is used with the @code{fcntl} function to describe a file
lock.  It has these members:

@table @code
@item short l_type
Specifies the type of the lock; one of @code{F_RDLCK}, @code{F_WRLCK}, or
@code{F_UNLCK}.

@item short l_whence
This corresponds to the @var{whence} argument to @code{fseek} or
@code{lseek}, and specifies what the offset is relative to.  Its value
can be one of @code{SEEK_SET}, @code{SEEK_CUR}, or @code{SEEK_END}.

@item off_t l_start
This specifies the offset of the start of the region to which the lock
applies, and is given in bytes relative to the @code{l_whence} member.

@item off_t l_len
This specifies the length of the region to be locked.  A value of
@code{0} is treated specially; it means the region extends to the end of
the file.

@item pid_t l_pid
This is the process ID (@pxref{Process Creation Concepts}) of the process
holding the lock.  It is filled in by calling @code{fcntl} with the
@code{F_GETLK} command, but is otherwise ignored.
@end table
@end deftp

@comment fcntl.h
@comment POSIX.1
@defvr Macro F_GETLK
This macro is used as the @var{command} argument to @code{fcntl}, to
specify that it should get information about a lock.  This command
requires a third argument of type @code{struct flock *} to be passed
to @code{fcntl}, so that the form of the call is:

@example
fcntl (@var{filedes}, F_GETLK, @var{lockp})
@end example

If there is a lock already in place that would block the lock described
by the @var{lockp} argument, information about that lock overwrites its
current contents.  In other words, you should specify a lock type of
@code{F_WRLCK} if you want to find out about both read and write locks,
or @code{F_RDLCK} if you want to find out about write locks only.

There might be more than one lock affecting the region specified by the
@var{lockp} argument, but @code{fcntl} only returns information about
the first such lock.  The @code{l_whence} member of the @var{lockp}
structure is set to @code{SEEK_SET} and the @code{l_start} and
@code{l_len} fields set to identify the locked region.

If no lock applies, the only change to the @var{lockp} structure is to
update the @code{l_type} to a value of @code{F_UNLCK}.

The normal return value from @code{fcntl} with this command is an
unspecified value other than @code{-1}, which is reserved to indicate an
error.  The following @code{errno} error conditions are defined for
this command:

@table @code
@item EBADF
The @var{filedes} argument is invalid.

@item EINVAL
Either the @var{lockp} argument doesn't specify valid lock information,
or the file associated with @var{filedes} doesn't support locks.
@end table
@end defvr

@comment fcntl.h
@comment POSIX.1
@defvr Macro F_SETLK
This macro is used as the @var{command} argument to @code{fcntl}, to
specify that it should set or clear a lock.  This command requires a
third argument of type @code{const struct flock *} to be passed to
@code{fcntl}, so that the form of the call is:

@example
fcntl (@var{filedes}, F_SETLK, @var{lockp})
@end example

If the process already has a lock on any part of the region, the old lock
on that part is replaced with the new lock.  Thus, you can remove a lock
by specifying the a lock type of @code{F_UNLCK}.

The normal return value from @code{fcntl} with this command is an
unspecified value other than @code{-1}.

If the lock cannot be set, @code{fcntl} returns immediately with a value
of @code{-1}.  This function does not block waiting for other processes
to release locks.

The following @code{errno} error conditions are defined for this
command:

@table @code
@item EACCES
The lock cannot be set because it is blocked by an existing lock 
on the file.

@item EAGAIN
The lock cannot be set because it is blocked by an existing lock 
on the file.

@item EBADF
Either: the @var{filedes} argument is invalid; you requested a read lock
but the @var{filedes} is not open for read access; or, you requested a
write lock but the @var{filedes} is not open for write access.

@item EINVAL
Either the @var{lockp} argument doesn't specify valid lock information,
or the file associated with @var{filedes} doesn't support locks.

@item ENOLCK
The system has run out of file lock resources; there are already too
many file locks in place.
@end table
@end defvr

@comment fcntl.h
@comment POSIX.1
@defvr Macro F_SETLKW
This macro is used as the @var{command} argument to @code{fcntl}, to
specify that it should set or clear a lock.  It is just like the
@code{F_SETLK} command, but causes the process to block (or wait)
until the request can be specified.

This command requires a third argument of type @code{const struct flock *},
as for the @code{F_SETLK} command.

The @code{fcntl} return values and errors are the same as for the
@code{F_SETLK} command, but these additional @code{errno} error conditions
are defined for this command:

@table @code
@item EINTR
The function was interrupted by a signal while it was waiting.

@item EDEADLK
A deadlock condition was detected.  This can happen if two processes
each already controlling a locked region request a lock on the same
region locked by the other process.
@end table
@end defvr


The following macros are defined for use as values for the @code{l_type}
member of the @code{flock} structure.  The values are integer constants.

@comment fcntl.h
@comment POSIX.1
@defvr Macro F_RDLCK
This macro is used to specify a read (or shared) lock.
@end defvr

@comment fcntl.h
@comment POSIX.1
@defvr Macro F_WRLCK
This macro is used to specify a write (or exclusive) lock.
@end defvr

@comment fcntl.h
@comment POSIX.1
@defvr Macro F_UNLCK
This macro is used to specify that the region is unlocked.
@end defvr

As an example of a situation where file locking is useful, consider a
program that can be run simultaneously by several different users, that
logs status information to a common file.  One example of such a program
might be a game that uses a file to keep track of high scores.  Another
example might be a program that records usage or accounting information
for billing purposes.

Having multiple copies of the program simultaneously writing to the
file could cause the contents of the file to become mixed up.  But
you can prevent this kind of problem by setting a write lock on the
file before actually writing to the file.  

If the program also needs to read the file and wants to make sure that
the contents of the file are in a consistent state, then it can also use
a read lock.  While the read lock is set, no other process can lock
that part of the file for writing.

@strong{Incomplete:}  This section needs an example.

Remember that file locks are only a @emph{voluntary} protocol for
controlling access to a file.  There is still potential for access to
the file by programs that don't use the lock protocol.

@node Other File Control Commands
@subsection Other File Control Commands

@strong{Incomplete:} I'm confused about what these commands really do.
Mib says that setting the foreground process group on a terminal file
descriptor also has the effect of setting the process group to receive
these signals.

These commands are provided for compatibility with BSD Unix.  In that
system, if you set the @code{FASYNC} flag on a file descriptor
(@pxref{wherever}), a @code{SIGIO} signal is sent to the indicated
process or process group.  This is also used to select a process to
receive a @code{SIGURG} signal when data arrives on a socket.

These macros for the @code{fcntl} function are defined in the header
file @file{<fcntl.h>}.

@comment fcntl.h
@comment BSD
@defvr Macro F_GETOWN
This macro is used as the @var{command} argument to @code{fcntl}, to
specify that it should get information about the process or process
group to which @code{SIGIO} signals are sent.  The return value is
interpreted as a process ID; if negative, its absolute value is the
process group ID.

The following @code{errno} error conditions are defined for this
command:

@table @code
@item EBADF
The @var{filedes} argument is invalid.
@end table
@end defvr

@comment fcntl.h
@comment BSD
@defvr Macro F_SETOWN
This macro is used as the @var{command} argument to @code{fcntl}, to
specify that it should set the process or process group to which
@code{SIGIO} signals are sent.  This command requires a third argument
of type @code{pid_t} to be passed to @code{fcntl}, so that the form of
the call is:

@example
fcntl (@var{filedes}, F_SETOWN, @var{pid})
@end example

The @var{pid} argument should be a process ID.  You can also pass a
negative number whose absolute value is the process group ID.

The return value from @code{fcntl} with this command is @code{-1}
in case of error and some other value if successful.  The following
@code{errno} error conditions are defined for this command:

@table @code
@item EBADF
The @var{filedes} argument is invalid.

@item ESRCH
There is no process or process group corresponding to @var{pid}.
@end table
@end defvr
