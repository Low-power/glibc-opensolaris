@node Memory Allocation
@chapter Memory Allocation

The GNU system provides several methods for allocating memory space
under explicit program control.  They vary in generality and in
efficiency.

@iftex
@itemize @bullet
@item
The @code{malloc} facility allows fully general dynamic allocation.
@xref{Unconstrained Allocation}.

@item
Obstacks are another facility, less general than malloc but more
efficient and convenient.  @xref{Obstacks}.

@item
The function @code{alloca} lets you allocate storage dynamically that
will be freed automatically.  @xref{Automatic Storage with Variable
Size}.
@end itemize
@end iftex

@menu
* Dynamic Memory Allocation::			An introduction to concepts
						 and terminology.
* Dynamic Allocation and C::			How to get different kinds of
						 allocation in C.
* Unconstrained Allocation::			The @code{malloc} facility
						 allows fully general
				 		 dynamic allocation.
* Obstacks::    				Obstacks are another facility,
						 less general than malloc but
						 more efficient and convenient.
* Automatic Storage with Variable Size::	Allocation of variable-sized
						 blocks of automatic storage
						 that are freed when the
						 calling function returns.
* Relocating Allocator::
@end menu

@node Dynamic Memory Allocation
@section Dynamic Memory Allocation
@cindex dynamic allocation
@cindex static allocation
@cindex automatic allocation

@dfn{Dynamic memory allocation} is a technique in which programs determine
as they are running where to store some information.

You need dynamic allocation when the number of memory blocks you need, or
how long you continue to need them, depends on the data you are working on.

For example, you may need a block to store a line read from an input file;
since there is no limit to how long a line can be, you must allocate the
storage dynamically and make it dynamically larger as you read more of the
line.

Or, you may need a block for each record or each definition in the input
data; since you can't know in advance how many there will be, you must
allocate a new block for each record or definition as you read it.

When you use dynamic allocation, the allocation of a block of memory is an
action that the program requests explicitly.  You call a function or macro
when you want to allocate space, and specify the size with an argument.  If
you want to free the space, you do so by calling another function or macro.
You can do these things whenever you want, as often as you want.

@node Dynamic Allocation and C
@section Dynamic Allocation and C

The C language supports two kinds of memory allocation through the variables
in C programs:

@itemize @bullet
@item
@dfn{Static allocation} is what happens when you declare a static
variable.  Each static variable defines one block of space, of a fixed
size.  The space is allocated once, when your program is started, and
is never freed.

@item
@dfn{Automatic allocation} happens when you declare an automatic
variable, such as a function argument or a local variable.  The space
for an automatic variable is allocated when the compound statement
containing the declaration is entered, and is freed when that
compound statement is exited.

In GNU C, the length of the automatic storage can be an expression
that varies.  In other C implementations, it must be a constant.
@end itemize

Dynamic allocation is not supported by C variables; there is no storage
class ``dynamic'', and there can never be a C variable whose value is
stored in dynamically allocated space.  The only way to refer to
dynamically allocated space is through a pointer.  Because it is less
convenient, and because the actual process of dynamic allocation
requires more computation time, you use dynamic allocation only when
neither static nor automatic allocation will serve.

For example, if you want to allocate dynamically some space to hold a
@code{struct foobar}, you cannot declare a variable of type @code{struct
foobar} whose contents are the dynamically allocated space.  But you can
declare a variable of pointer type @code{struct foobar *} and assign it the
address of the space.  Then you can use the operators @samp{*} and
@samp{->} on this pointer variable to refer to the contents of the space:

@example
@{
  struct foobar *ptr
     = (struct foobar *) malloc (sizeof (struct foobar));
  ptr->name = x;
  current_foobar = ptr;
@}
@end example

@node Unconstrained Allocation
@section Unconstrained Allocation

The most general dynamic allocation facility is @code{malloc}.  It allows
you to allocate blocks of memory of any size at any time, make them bigger
or smaller at any time, and free the blocks in any order (or never).

@menu
* Basic Storage Allocation::		Simple use of @code{malloc}.
* Freeing Allocated Memory::		Use @code{free} to free a block you
					 got with @code{malloc}.
* Changing the Size of a Block::	Use @code{realloc} to make a block
					 bigger or smaller.
* Allocating Cleared Space::		Use @code{calloc} to allocate a
					 block and clear it.
* Efficiency Considerations::	Efficiency considerations in use of
					 these functions.
* Allocation with Specified Alignment::	Allocating specially aligned memory:
					 @code{memalign} and @code{valloc}.
* Heap Consistency Checking::		Automatic checking for errors.
* Storage Allocation Hooks::		You can use these hooks for debugging
					 programs that use @code{malloc}.
* Storage Allocation Statistics::	Getting information about how much
					 memory your program is using.
* Summary of @code{malloc} and Related Functions::         Malloc Summary.
@end menu

@node Basic Storage Allocation
@subsection Basic Storage Allocation
@cindex allocation (random-access)

To allocate a block of memory, call @code{malloc}.  The prototype for
this function is in @file{<stdlib.h>}.

@comment malloc.h stdlib.h
@comment ANSI
@deftypefun {void *} malloc (size_t @var{size})
This function returns a pointer to a newly allocated block @var{size}
bytes long, or a null pointer if the block could not be allocated.
@end deftypefun

The contents of the block are undefined; you must initialize it yourself
(or use @code{calloc} instead; @pxref{Allocating Cleared Space}).
Normally you would cast the value as a pointer to the kind of object
that you want to store in the block.  Here we show an example of doing
so, and of initializing the space with zeros using the library function
@code{memset} (@pxref{Copying and Concatenation}):

@example
struct foo *ptr;
@dots{}
ptr = (struct foo *) malloc (sizeof (struct foo));
if (ptr == 0) abort ();
memset (ptr, 0, sizeof (struct foo));
@end example

You can store the result of @code{malloc} into any pointer variable
without a cast, because ANSI C automatically converts the type
@code{void *} to another type of pointer when necessary.  But the cast
is necessary in contexts other than assignment operators or if you might
want your code to run in traditional C.

Remember that when allocating space for a string, the argument to
@code{malloc} must be one plus the length of the string.  This is
because a string is terminated with a null character that doesn't count
in the ``length'' of the string but does need space.  For example:

@example
char *ptr;
@dots{}
ptr = (char *) malloc (length + 1);
@end example

@noindent
@xref{Representation of Strings}, for more information about this.

If no more space is available, @code{malloc} returns a null pointer.
You should check the value of @emph{every} call to @code{malloc}.  It is
useful to write a subroutine that calls @code{malloc} and reports an
error if the value is a null pointer, returning only if the value is
nonzero.  This function is conventionally called @code{xmalloc}.  Here
it is:

@example
void *
xmalloc (size_t size)
@{
  register void *value = malloc (size);
  if (value == 0)
    fatal ("virtual memory exhausted");
  return value;
@}
@end example

Here is a real example of using @code{malloc} (by way of @code{xmalloc}).
The function @code{savestring} will copy a sequence of characters into
a newly allocated null-terminated string:

@example
char *
savestring (char *ptr, size_t len)
@{
  register char *value = (char *) xmalloc (len + 1);
  memcpy (value, ptr, len);
  value[len] = 0;
  return value;
@}
@end example

The block that @code{malloc} gives you is guaranteed to be aligned so
that it can hold any type of data.  In the GNU system, this means the
address is always a multiple of eight.  Only rarely is any higher
boundary (such as a page boundary) necessary; for those cases, use
@code{memalign} or @code{valloc} (@pxref{Allocation with Specified
Alignment}).

Note that the memory located after the end of the block is likely to be
in use for something else; perhaps a block already allocated by another
call to @code{malloc}.  If you attempt to treat the block as longer than
you asked for it to be, you are liable to destroy the data that
@code{malloc} uses to keep track of its blocks, or you may destroy the
contents of another block.  If you have already allocated a block and
discover you want it to be bigger, use @code{realloc} (@pxref{Changing
the Size of a Block}).

@node Freeing Allocated Memory
@subsection Freeing Allocated Memory
@cindex freeing (random-access)

When you no longer need a block that you got with @code{malloc}, use the
function @code{free} to make the block available to be allocated again.
The prototype for this function is in @file{<stdlib.h>}.

@comment malloc.h stdlib.h
@comment ANSI
@deftypefun void free (void *@var{ptr})
The @code{free} function deallocates the block of storage pointed at
by @var{ptr}.
@end deftypefun

@comment stdlib.h
@comment GNU
@deftypefun void cfree (void *@var{ptr})
This function does the same thing as @code{free}.  It's provided for
backward compatibility with SunOS; you should use @code{free} instead.
@end deftypefun

Freeing a block alters the contents of the block.  @strong{Do not expect to
find any data (such as a pointer to the next block in a chain of blocks) in
the block after freeing it.}  Copy whatever you need out of the block before
freeing it!  Here is an example of the proper way to free all the blocks in
a chain, and the strings that they point to:

@example
struct chain @{
  struct chain *next;
  char *name;
@}

void
free_chain (struct chain *chain)
@{
  while (chain != 0) @{
    struct chain *next = chain->next;
    free (chain->name);
    free (chain);
    chain = next;
  @}
@}
@end example

You cannot reduce the total memory space used by the program by calling
@code{free}, because @code{free} does not currently know how to return the
memory to the operating system.  The purpose of calling @code{free} is to
allow a later later call to @code{malloc} to reuse the space.  In the mean
time, the space remains in your program as part of a free-list used
internally by @code{malloc}.

Therefore, there is no point in freeing blocks at the end of a program,
when you are not going to allocate any more.

@node Changing the Size of a Block
@subsection Changing the Size of a Block
@cindex changing size

Often you do not know for certain how big a block you will ultimately need
at the time you must begin to use the block.  For example, the block might
be a buffer that you use to hold a line being read from a file; no matter
how long you make the buffer initially, you may encounter a line that is
longer.

You can make the block longer by calling @code{realloc}.  This function
is declared in @file{<stdlib.h>}.

@comment malloc.h stdlib.h
@comment ANSI
@deftypefun {void *} realloc (void *@var{ptr}, size_t @var{newsize})
The @code{realloc} function changes the size of the block whose address is
@var{ptr} to be @var{newsize}.

Since the space after the end of the block may be in use, @code{realloc}
may find it necessary to copy the block to a new address where more free
space is available.  The value of @code{realloc} is the new address of the
block.  If the block needs to be moved, @code{realloc} copies the old
contents.
@end deftypefun

Like @code{malloc}, @code{realloc} may return a null pointer if no
memory space is available to make the block bigger.  When this happens,
the original block is not modified or reallocated.

In most cases it makes no difference what happens to the original block
when @code{realloc} fails, because the application program cannot continue
when it is out of memory, and the only thing to do is to give a fatal error
message.  Often it is convenient to write and use a subroutine,
conventionally called @code{xrealloc}, that takes care of the error message
as @code{xmalloc} does for @code{malloc}:

@example
void *
xrealloc (void *ptr, size_t size)
@{
  register void *value = realloc (ptr, size);
  if (value == 0)
    fatal ("Virtual memory exhausted.");
  return value;
@}
@end example

You can also use @code{realloc} to make a block smaller.  The reason you
would do this is to avoid tying up a lot of memory space when only a little
is needed.  Making a block smaller sometimes necessitates copying it, so it
can fail if no other space is available.

If the new size you specify is the same as the old size, @code{realloc}
is guaranteed to change nothing and return the same address that you gave.

@node Allocating Cleared Space
@subsection Allocating Cleared Space

The function @code{calloc} allocates memory and clears it to zero.  It
is declared in @file{<stdlib.h>}.

@comment malloc.h stdlib.h
@comment ANSI
@deftypefun {void *} calloc (size_t @var{count}, size_t @var{eltsize})
This function allocates a block long enough to contain a vector of
@var{count} elements, each of size @var{eltsize}.  Its contents are
cleared to zero before @code{calloc} returns.
@end deftypefun

You could define @code{calloc} as follows:

@example
void *
calloc (size_t count, size_t eltsize)
@{
  size_t size = count * eltsize;
  void *value = malloc (size);
  if (value != 0)
    memset (value, 0, size);
  return value;
@}
@end example

People rarely use @code{calloc}, because it is equivalent to such a simple
combination of other features that are more often used.  It is a historical
holdover that is not quite obsolete.


@node Efficiency Considerations
@subsection Efficiency Considerations
@cindex efficiency and @code{malloc}

@strong{Incomplete:}  This material may be inaccurate.

To make the best use of @code{malloc}, it helps to know that @code{malloc}
always dispenses memory in units of powers of two.  It keeps separate pools
for each power of two.

Therefore, if you are free to choose the size of a block in order to make
@code{malloc} more efficient, make it a power of two.

The pools for different powers of two remain separate forever; a block
of 32 bytes can never be split into two blocks of 16 bytes.  So it is
good if you manage to use blocks of the same size for as many different
purposes as possible.

@node Allocation with Specified Alignment
@subsection Allocation with Specified Alignment

@cindex page boundary
@cindex alignment (with malloc)
The address of a block returned by @code{malloc} or @code{realloc} in
the GNU system is always a multiple of eight.  If you need a block whose
address is a multiple of a higher power of two than that, use
@code{memalign} or @code{valloc}.  These functions are declared in
@file{<stdlib.h>}.

@strong{Incomplete:}  @code{memalign} is not actually defined!!

@comment malloc.h stdlib.h
@comment BSD
@deftypefun {void *} memalign (size_t @var{size}, int @var{boundary})
The @code{memalign} function allocates a block of @var{size} bytes whose
address is a multiple of @var{boundary}.  The @var{boundary} must be a
power of two!  It works by calling @code{malloc} to allocate a somewhat
larger block, and then returning an address within the block that is on
the desired boundary.
@end deftypefun

@comment malloc.h stdlib.h
@comment BSD
@deftypefun {void *} valloc (size_t @var{size})
Using @code{valloc} is like using @code{memalign} and passing the page size
as the value of the second argument.  Its advantage is that you don't need
to determine the page size explicitly (something which cannot be done
portably on Unix systems).
@end deftypefun


@node Heap Consistency Checking
@subsection Heap Consistency Checking

@cindex heap consistency checking
@cindex consistency checking, of heap

You can ask @code{malloc} to check the consistency of the heap by using
the @code{mcheck} function.  This function is a GNU extension, declared
in @file{<malloc.h>}.

@comment malloc.h
@comment GNU
@deftypefun void mcheck (void (*@var{abortfn}) (void))
Calling @code{mcheck} tells @code{malloc} to perform occasional
consistency checks on the heap.  These will catch things such as writing
past the end of a @code{malloc}ed block.

The @var{abortfn} argument is the function to call when an inconsistency
is found.  If you supply a null pointer, the @code{abort} function is
used.
@end deftypefun

Since other library functions (such as the standard i/o functions) may
call @code{malloc}, you should do @code{mcheck} before anything else in
your program.  To do this automatically, link with @samp{-lmcheck}.

@node Storage Allocation Hooks
@subsection Storage Allocation Hooks

The GNU C Library lets you modify the behavior of @code{malloc},
@code{realloc}, and @code{free} by specifying appropriate hook
functions.  You can use these hooks to help you debug programs that use
dynamic storage allocation, for example.

The hook variables are declared in @file{<malloc.h>}.

@comment malloc.h
@comment GNU
@defvar __malloc_hook
The value of this variable is a pointer to function that @code{malloc}
uses whenever it is called.  You should define this function to look
like @code{malloc}; that is, like:

@example
void *@var{function} (size_t @var{size})
@end example
@end defvar

@comment malloc.h
@comment GNU
@defvar __realloc_hook
The value of this variable is a pointer to function that @code{realloc}
uses whenever it is called.  You should define this function to look
like @code{realloc}; that is, like:

@example
void *@var{function} (void *@var{ptr}, size_t @var{size})
@end example
@end defvar

@comment malloc.h
@comment GNU
@defvar __free_hook
The value of this variable is a pointer to function that @code{free}
uses whenever it is called.  You should define this function to look
like @code{free}; that is, like:

@example
void @var{function} (void *@var{ptr})
@end example
@end defvar

You must make sure that the function you install as a hook for one of
these functions does not call that function recursively without restoring
the old value of the hook first!  Otherwise, your program will get stuck
in an infinite recursion.

Here is an example showing how to use @code{__malloc_hook} properly.  It
installs a function that prints out information every time @code{malloc}
is called.

@example
static void *(*old_malloc_hook) (size_t);
static void *
my_malloc_hook (size_t size)
@{
  void *result;
  __malloc_hook = old_malloc_hook;
  result = malloc (size);
  __malloc_hook = my_malloc_hook;
  printf ("malloc (%u) returns %p\n", (unsigned int) size, result);
  return result;
@}

main ()
@{
  ...
  old_malloc_hook = __malloc_hook;
  __malloc_hook = my_malloc_hook;
  ...
@}
@end example

The @code{mcheck} function (@pxref{Heap Consistency Checking}) works by
installing such hooks.



@node Storage Allocation Statistics
@subsection Storage Allocation Statistics

In the GNU C Library, you can get information about dynamic storage
allocation by calling the @code{mstats} function.  This function and
its associated data type are declared in @file{<malloc.h>}.

@comment malloc.h
@comment GNU
@deftp {struct Type} mstats
This structure type is used to return information about the dynamic
storage allocator.  It contains the following members:

@table @code
@item size_t bytes_total
This is the total size of the heap, in bytes.

@item size_t chunks_used
This is the number of chunks in use.  (The storage allocator internally
gets chunks of memory from the operating system, and them carves them up
to satisfy individual @code{malloc} requests; @pxref{Efficiency
Considerations}.)

@item size_t bytes_used
This is the number of bytes in use.

@item size_t chunks_free
This is the number of chunks which are free -- that is, that have been
allocated by the operating system to your program, but which are not
now being used.

@item size_t bytes_free
This is the number of bytes which are free.
@end table
@end deftp

@comment malloc.h
@comment GNU
@deftypefun struct mstats mstats (void)
This function returns information about the current dynamic memory usage
in a structure of type @code{struct mstats}.
@end deftypefun


@node Summary of @code{malloc} and Related Functions
@subsection Summary of @code{malloc} and Related Functions

Here is a summary of the functions that work with @code{malloc}:

@table @code
@item malloc (@var{size})
Allocate a block of @var{size} bytes.  @xref{Basic Storage Allocation}.

@item free (@var{addr})
Free a block previously allocated by @code{malloc}.  @xref{Freeing
Allocated Memory}.

@item realloc (@var{addr}, @var{size})
Make a block previously allocated by @code{malloc} larger or smaller,
possibly by copying it to a new location.  @xref{Changing the Size of a
Block}.

@item calloc (@var{count}, @var{eltsize})
Allocate a block of @var{count} * @var{eltsize} bytes using
@code{malloc}, and set its contents to zero.  @xref{Allocating Cleared
Space}.

@item valloc (@var{size})
Allocate a block @var{size} bytes, starting on a page boundary.
@xref{Allocation with Specified Alignment}.

@item memalign (@var{size}, @var{boundary})
Allocate a block @var{size} bytes, starting on an address that is a
multiple of @var{boundary}.  @xref{Allocation with Specified Alignment}.
@end table


@node Obstacks
@section Obstacks
@cindex obstacks

@strong{Incomplete:}  Obstacks are not now part of the GNU C Library.
You must specify @samp{-lobstack} when linking to use these functions.

@strong{Incomplete:} The functions in this section take @code{int}
arguments for sizes.  For consistency, these should all be documented
as @code{size_t} instead.

An @dfn{obstack} is a pool of memory containing a stack of objects.  You
can create any number of separate obstacks, and then allocate objects in
specified obstacks.  Within each obstack, the last object allocated must
always be the first one freed, but distinct obstacks are independent of
each other.

Aside from this one constraint of order of freeing, obstacks are totally
general: an obstack can contain any number of objects of any size.  They
are implemented with macros, so allocation is usually very fast as long as
the objects are usually small.  And the only space overhead per object is
the padding needed to start each object on a suitable boundary.

@menu
* Representation of Obstacks::		How to declare an obstack in your
					 program.
* Allocation in an Obstack::		Allocating objects in an obstack.
* Freeing Objects in an Obstack::	Freeing objects in an obstack.
* Preparing to Use Obstacks::		Preparations needed before you can
					 use obstacks.
* Obstack Functions and Macros::	The obstack functions are both
					 functions and macros.
* Growing Objects::			Making an object bigger by stages.
* Extra Fast Growing Objects::		Extra-high-efficiency (though more
					 complicated) growing.
* Status of an Obstack::		Inquiries about the status of an
					 obstack.
* Alignment of Data in Obstacks::	Controlling alignment of objects
					 in obstacks.
* Obstack Chunks::			How obstacks obtain and release chunks.
					 Efficiency considerations.
* Obstacks and Signal Handling::	Don't try to use obstack functions
					 in a signal handler.
* Summary of Obstack Functions::	Obstack Summary.
@end menu

@node Representation of Obstacks
@subsection Representation of Obstacks

The utilities for manipulating obstacks are declared in the header
file @file{<obstack.h>}.

@comment obstack.h
@comment GNU
@deftp {struct Type} obstack
An obstack is represented by a data structure of type @code{struct
obstack}.  This structure has a small fixed size; it records the status
of the obstack and how to find the space in which objects are allocated.
It does not contain any of the objects themselves.  You should not try
to access the contents of the structure directly; use only the functions
described in this chapter.
@end deftp

You can declare variables of type @code{struct obstack} and use them as
obstacks, or you can allocate obstacks dynamically like any other kind
of object.  Dynamic allocation of obstacks allows your program to have a
variable number of different stacks.  (You could even allocate an
obstack structure in another obstack, but this probably isn't useful.)

The objects in the obstack are packed into large blocks called
@dfn{chunks}.  The @code{struct obstack} structure points to a chain of
the chunks currently in use.

The obstack library obtains a new chunk whenever you allocate an object
that won't fit in the previous chunk.  Since the obstack library manages
chunks automatically, you don't need to pay much attention to them, but
you do need to supply a function which the obstack library should use to
get a chunk.  Usually you supply a function which uses @code{malloc}
directly or indirectly.

@comment obstack.h
@comment GNU
@deftypefun void obstack_init (struct obstack *@var{obstack})
Before you can use a @code{struct obstack} object as an obstack, you must
initialize it with the function @code{obstack_init}.
@end deftypefun

Here are two examples of how to allocate the space for an obstack and
initialize it.  First, an obstack that is a static variable:

@example
struct obstack myobstack;
@dots{}
obstack_init (&myobstack);
@end example

@noindent
Second, an obstack that is itself dynamically allocated:

@example
struct obstack *myobstack_ptr
      = ((struct obstack *)
         xmalloc (sizeof (struct obstack)));

obstack_init (myobstack_ptr);
@end example

Each source file that uses @code{obstack_init} must contain definitions of
@code{obstack_chunk_alloc} and @code{obstack_chunk_free}.
@xref{Preparing to Use Obstacks}.

@node Allocation in an Obstack
@subsection Allocation in an Obstack
@cindex allocation (obstacks)

The most direct way to allocate an object in an obstack is with
@code{obstack_alloc}, which is invoked almost like @code{malloc}.

@comment obstack.h
@comment GNU
@deftypefun {void *} obstack_alloc (struct obstack *@var{obstack_ptr}, int @var{size})
This allocates an uninitialized block of @var{size} bytes and returns its
address.  Here @var{obstack_ptr} specifies which obstack to allocate the
block in; it is the address of the @code{struct obstack} object which
represents the obstack.  Each obstack function or macro requires you to
specify an @var{obstack_ptr} as the first argument.
@end deftypefun

For example, here is a function that allocates a copy of a string @var{str}
in a specific obstack, which is the variable @code{string_obstack}:

@example
struct obstack string_obstack;

char *
copystring (char *string)
@{
  char *s = (char *) obstack_alloc (&string_obstack,
                                    strlen (string) + 1);
  memcpy (s, string, strlen (string));
  return s;
@}
@end example

To allocate a block with specified contents, use the function
@code{obstack_copy}, declared like this:

@comment obstack.h
@comment GNU
@deftypefun {void *} obstack_copy (struct obstack *@var{obstack_ptr}, void *@var{address}, int @var{size})
This initializes the newly allocated block with a copy of the @var{size}
bytes of data starting at @var{address}.
@end deftypefun

@comment obstack.h
@comment GNU
@deftypefun {void *} obstack_copy0 (struct obstack *@var{obstack_ptr}, void *@var{address}, int @var{size})
The function @code{obstack_copy0} is similar to @code{obstack_copy};
the difference is that @code{obstack_copy0} appends an extra byte
containing a null character.  This extra byte is not counted in the argument
@var{size}.
@end deftypefun

The @code{obstack_copy0} function is convenient for copying a sequence
of characters into an obstack as a null-terminated string.  Here is an
example of its use:

@example
char *
obstack_savestring (char *addr, int size)
@{
  return obstack_copy0 (&myobstack, addr, size);
@}
@end example

@noindent
Contrast this with the previous example of @code{savestring} using
@code{malloc} (@pxref{Basic Storage Allocation}).

@node Freeing Objects in an Obstack
@subsection Freeing Objects in an Obstack
@cindex freeing (obstacks)

To free an object allocated in an obstack, use the function
@code{obstack_free}.

@comment obstack.h
@comment GNU
@deftypefun void obstack_free (struct obstack *@var{obstack_ptr}, void *@var{object})
If @var{object} is a null pointer, everything allocated in the obstack
is freed.  Otherwise, @var{object} must be the address of an object
allocated in the obstack.  Then @var{object} is freed, and so is every
object that was allocated in the same obstack more recently than
@var{object}.
@end deftypefun

Note that if @var{object} is a null pointer, the result is an
uninitialize obstack.  To free all storage in an obstack but leave it
valid for further allocation, call @code{obstack_free} with the address
of the first object allocated on the obstack:

@example
obstack_free (obstack_ptr, first_object_allocated_ptr);
@end example

Recall that the objects in an obstack are grouped into chunks.  When all
the objects in a chunk become free, the obstack library automatically
frees the chunk (@pxref{Preparing to Use Obstacks}).  Then other
obstacks, or non-obstack allocation, can reuse the space of the chunk.

@node Preparing to Use Obstacks
@subsection Preparing to Use Obstacks
@cindex header file
@cindex linking

@strong{Incomplete:}  This section needs to be rewritten when it is
decided whether obstacks will be part of the C library.

Each source file in which you plan to use the obstack functions
must include the header file @file{obstack.h}, like this:

@example
#include <obstack.h>
@end example

@findex obstack_chunk_alloc
@findex obstack_chunk_free
Also, if the source file uses the macro @code{obstack_init}, it must
declare or define two functions or macros that will be called by the
obstack library.  One, @code{obstack_chunk_alloc}, is used to allocate the
chunks (large blocks) of memory into which objects are packed.  The other,
@code{obstack_chunk_free}, is used to return chunks when the objects in
them are freed.

Usually these are defined to use @code{malloc} via the intermediary
@code{xmalloc} (@pxref{Unconstrained Allocation}).  This is done with
the following pair of macro definitions:

@example
#define obstack_chunk_alloc xmalloc
#define obstack_chunk_free free
@end example

@noindent
Though the storage you get using obstacks really comes from @code{malloc},
using obstacks is faster because @code{malloc} is called less often, for
larger blocks of memory.  @xref{Obstack Chunks}, for full details.

Finally, when you link your program you must include among the object files
the file of obstack support functions, @samp{obstack.o}.  In the actual GNU
system, this will no longer be necessary, because these subroutines will be
in the C library.


@node Obstack Functions and Macros
@subsection Obstack Functions and Macros
@cindex macros

The interfaces for using obstacks may be defined either as functions or as
macros, depending on the compiler.



If you are using an old-fashioned non-ANSI C compiler, they are actually
defined only as macros.  You can call these macros like functions, but
you cannot use them in any other way (for example, you cannot take their
address).

Calling the macros requires a special precaution: namely, the first operand
(the obstack pointer) may not contain any side effects, because it may be
computed more than once.  For example, if you write this:

@example
obstack_alloc (get_obstack (), 4);
@end example

@noindent
you will find that @code{get_obstack} may be called several times.
If you use @code{*obstack_list_ptr++} as the obstack pointer argument,
you will get very strange results since the incrementation may occur
several times.

In ANSI C, each function has both a macro definition and a function
definition.  The function definition is used if you take the address of the
function without calling it.  An ordinary call uses the macro definition by
default, but you can request the function definition instead by writing the
function name in parentheses, as shown here:

@example
char *x;
void *(*funcp) ();
/* @r{Use the macro} */
x = (char *) obstack_alloc (obptr, size);
/* @r{Call the function} */
x = (char *) (obstack_alloc) (obptr, size);
/* @r{Take the address of the function} */
funcp = obstack_alloc;
@end example

@noindent
This is the same situation that exists in ANSI C for the standard library
functions.  @xref{Macro Definitions}.

If you are not using the GNU C compiler, you must observe the precaution
of avoiding side effects in the first operand.  But if you use the GNU C
compiler, no precautions are necessary, because various language
extensions in GNU C allow the macros to be defined in a way that avoids
unwanted recalculation.

@node Growing Objects
@subsection Growing Objects
@cindex growing objects (in obstacks)
@cindex changing size (in obstacks)

Because storage in obstack chunks is used sequentially, it is possible to
build up an object step by step, adding one or more bytes at a time to the
end of the object.  With this technique, you do not need to know how much
data you will put in the object until you come to the end of it.  We call
this the technique of @dfn{growing objects}.  The special functions
for adding data to the growing object are described in this section.

You don't need to do anything special when you start to grow an object.
Using one of the functions to add data to the object automatically
starts it.  However, it is necessary to say explicitly when the object is
finished.  This is done with the function @code{obstack_finish}.

The actual address of the object thus built up is not known until the
object is finished.  Until then, it always remains possible that you will
add so much data that the object must be copied into a new chunk.

While the obstack is in use for a growing object, you cannot use it for
ordinary allocation of another object.  If you try to do so, the space
already added to the growing object will become part of the other object.

@comment obstack.h
@comment GNU
@deftypefun void obstack_blank (struct obstack *@var{obstack_ptr}, int @var{size})
The most basic function for adding to a growing object is
@code{obstack_blank}, which adds space without initializing it.
@end deftypefun

@comment obstack.h
@comment GNU
@deftypefun void obstack_grow (struct obstack *@var{obstack_ptr}, void *@var{data}, int @var{size})
To add a block of initialized space, use @code{obstack_grow}, which is
the growing-object analogue of @code{obstack_copy}.

Here @var{size} is the number of bytes to add, and @var{data} points
to the data to initialize them with.
@end deftypefun

@comment obstack.h
@comment GNU
@deftypefun void obstack_grow (struct obstack *@var{obstack_ptr}, void *@var{data}, int @var{size})
This is the growing-object analogue of @code{obstack_copy0}.  It adds an
additional null character after the @var{size} specified bytes.
@end deftypefun

@comment obstack.h
@comment GNU
@deftypefun void obstack_1grow (struct obstack *@var{obstack_ptr},
                    char @var{data_char})
To add one character at a time, use the function
@code{obstack_1grow}.  
A single byte containing @var{data_char} is added to the growing object.
@end deftypefun

@comment obstack.h
@comment GNU
@deftypefun {void *} obstack_finish (struct obstack *@var{obstack_ptr})
When you are finished growing the object, use the function
@code{obstack_finish} to close it off and obtain its final address.

Once you have finished the object, the obstack is available for ordinary
allocation or for growing another object.
@end deftypefun

When you build an object by growing it, you will probably need to know
afterward how long it became.  You need not keep track of this as you grow
the object, because you can find out the length from the obstack just
before finishing the object with the function @code{obstack_object_size},
declared as follows:

@comment obstack.h
@comment GNU
@deftypefun int obstack_object_size (struct obstack *@var{obstack_ptr})
This function returns the current size of the growing object, in bytes.
Remember to call this function @emph{before} finishing the object.  Once
you finish the object, @code{obstack_object_size} will return zero.
@end deftypefun

If you have started growing an object and wish to cancel it, you should
finish it and then free it, like this:

@example
obstack_free (obstack_ptr, obstack_finish (obstack_ptr));
@end example

@noindent
This has no effect if no object was growing.

@node Extra Fast Growing Objects
@subsection Extra Fast Growing Objects
@cindex efficiency and obstacks

The usual functions for growing objects incur overhead for checking
whether there is room for the new growth in the current chunk.  If you are
frequently construct objects in small steps of growth, this overhead can be
significant.

You can reduce the overhead by using special ``fast growth''
functions that grow the object without checking.  In order to have a
robust program, you must do the checking yourself.  If you do this checking
in the simplest way each time you are about to add data to the object, you
have not saved anything, because that is what the ordinary growth
functions do.  But if you can arrange to check less often, or check
more efficiently, then you make the program faster.

The function @code{obstack_room} returns the amount of room available
in the current chunk.  It is declared as follows:

@comment obstack.h
@comment GNU
@deftypefun int obstack_room (struct obstack *@var{obstack_ptr})
This returns the number of bytes that can be added safely to the current
growing object (or to an object about to be started) in obstack
@var{obstack} using the fast growth functions.
@end deftypefun

While you know there is room, you can use these fast growth functions
for adding data to a growing object:

@comment obstack.h
@comment GNU
@deftypefun void obstack_1grow_fast (struct obstack *@var{obstack_ptr}, char @var{data_char})
The function @code{obstack_1grow_fast} adds one byte containing the
character @var{data_char} to the growing object @var{obstack_ptr}.
@end deftypefun

@comment obstack.h
@comment GNU
@deftypefun void obstack_blank_fast (struct obstack *@var{obstack_ptr}, int @var{size})
The function @code{obstack_blank_fast} adds @code{size} bytes to the
growing object @var{obstack_ptr} without initializing them.
@end deftypefun

When you check for space using @code{obstack_room} and there is not
enough room for what you want to add, the fast growth functions
are not safe.  In this case, simply use the corresponding ordinary
growth function instead.  Very soon this will copy the object to a
new chunk; then there will be lots of room available again. 

So, each time you use an ordinary growth function, check again for
sufficient space using @code{obstack_room}.  Once the object is copied
to a new chunk, there will be enough space again, so you will start
using the fast growth functions again.

Here is an example:

@example
void
add_string (struct obstack *obstack, char *ptr, int len)
@{
  while (len > 0)
    @{
      if (obstack_room (obstack) > len)
        @{
          /* We have enough room: add everything fast.  */
          while (len-- > 0)
            obstack_1grow_fast (obstack, *ptr++);
        @}
      else
        @{
          /* Not enough room. Add one character slowly,
             which may copy to a new chunk and make room.  */
          obstack_1grow (obstack, *ptr++);
          len--;
        @}
    @}
@}
@end example

@node Status of an Obstack
@subsection Status of an Obstack
@cindex obstack status
@cindex status of obstack

Here are functions that provide information on the current status of
allocation in an obstack.  You can use them to learn about an object while
still growing it.

@comment obstack.h
@comment GNU
@deftypefun {void *} obstack_base (struct obstack *@var{obstack})
This function teturns the tentative address of the beginning of the currently
growing object in @var{obstack}.  If you finish the object
immediately, it will have that address.  If you make it larger first,
it may outgrow the current chunk---then its address will change!

If no object is growing, this value says where the next object you
allocate will start (once again assuming it fits in the current
chunk).
@end deftypefun

@comment obstack.h
@comment GNU
@deftypefun {void *} obstack_next_free (struct obstack *@var{obstack})
This function returns the address of the first free byte in the current
chunk of @var{obstack}.  This is the end of the currently growing
object.  If no object is growing, @code{obstack_next_free} returns the
same value as @code{obstack_base}.
@end deftypefun

@comment obstack.h
@comment GNU
@deftypefun int obstack_object_size (struct obstack *@var{obstack})
This function returns the size in bytes of the currently growing object.
This is equivalent to

@example
obstack_next_free (@var{obstack}) - obstack_base (@var{obstack})
@end example
@end deftypefun

@node Alignment of Data in Obstacks
@subsection Alignment of Data in Obstacks
@cindex alignment (in obstacks)

Each obstack has an @dfn{alignment boundary}; each object allocated in
the obstack automatically starts on an address that is a multiple of the
specified boundary.  By default, this boundary is 4 bytes.

To access an obstack's alignment boundary, use the macro
@code{obstack_alignment_mask}, whose function prototype looks like
this:

@comment obstack.h
@comment GNU
@deftypefun int obstack_alignment_mask (struct obstack *@var{obstack_ptr})
The value is a bit mask; a bit that is 1 indicates that the corresponding
bit in the address of an object should be 0.  The mask value should be one
less than a power of 2; the effect is that all object addresses are
multiples of that power of 2.  The default value of the mask is 3, so that
addresses are multiples of 4.  A mask value of 0 means an object can start
on any multiple of 1 (that is, no alignment is required).

The expansion of the macro @code{obstack_alignment_mask} is an lvalue,
so you can alter the mask by assignment.  For example, this statement:

@example
obstack_alignment_mask (obstack_ptr) = 0;
@end example

@noindent
has the effect of turning off alignment processing in the specified obstack.
@end deftypefun

Note that a change in alignment mask does not take effect until
@emph{after} the next time an object is allocated or finished in the
obstack.  If you are not growing an object, you can make the new
alignment mask take effect immediately by calling @code{obstack_finish}.
This will finish a zero-length object and then do proper alignment for
the next object.

@node Obstack Chunks
@subsection Obstack Chunks
@cindex efficiency of chunks
@cindex chunks

Obstacks work by allocating space for themselves in large chunks, and then
parcelling out space in the chunks to satisfy your requests.  Chunks are
normally 4092 bytes long unless you specify a different chunk size.  The
chunk size includes 8 bytes of overhead that are not actually used for
storing objects.  Regardless of the specified size, longer chunks will be
allocated when necessary for long objects.

The obstack library allocates chunks by calling the function
@code{obstack_chunk_alloc}, which you must define.  When a chunk is no
longer needed because you have freed all the objects in it, the obstack
library frees the chunk by calling @code{obstack_chunk_free}, which you
must also define.

These two must be defined (as macros) or declared (as functions) in each
source file that uses @code{obstack_init} (@pxref{Representation of Obstacks}).
Most often they are defined as macros like this:

@example
#define obstack_chunk_alloc xmalloc
#define obstack_chunk_free free
@end example

Note that these are simple macros (no arguments).  Macro definitions with
arguments will not work!  It is necessary that @code{obstack_chunk_alloc}
or @code{obstack_chunk_free}, alone, expand into a function name if it is
not itself a function name.

The function that actually implements @code{obstack_chunk_alloc} cannot
return ``failure'' in any fashion, because the obstack library is not
prepared to handle failure.  Therefore, @code{malloc} itself is not
suitable.  If the function cannot obtain space, it should either terminate
the process or do a nonlocal exit using @code{longjmp}.

Because chunks are usually obtained with @code{malloc}, the chunk size
should be 4 less than a power of 2.  The default chunk size, 4092, was
chosen because it fits this constraint, and it is long enough to satisfy
many typical requests on the obstack yet short enough not to waste too much
memory the portion of the last chunk not yet used.

@comment obstack.h
@comment GNU
@deftypefun int obstack_chunk_size (struct obstack *@var{obstack_ptr})
This returns the chunk size of the given obstack.
@end deftypefun

Since this macro expands to an lvalue, you can specify a new chunk size by
assigning it a new value.  Doing so does not affect the chunks already
allocated, but will change the size of chunk allocated for that particular
obstack in the future.  It is unlikely to be useful to make the chunk size
smaller, but making it larger might improve efficiency if you are
allocating many objects whose size is comparable to the chunk size.  Here
is how to do so cleanly:

@example
if (obstack_chunk_size (obstack_ptr) < @var{new_chunk_size})
  obstack_chunk_size (obstack_ptr) = @var{new_chunk_size};
@end example

@node Obstacks and Signal Handling
@subsection Obstacks and Signal Handling
@cindex signals and obstacks

Is it safe to use @code{obstack_alloc} in a signal handler?  Yes, provided
you are careful in the following ways:

@itemize @bullet
@item
Use an obstack that you are certain the interrupted program is not
trying to allocate or free in at the time the signal happens.  (For
example, you may have a special obstack for use in signal handlers.)

@item
Make sure that the @code{obstack_chunk_alloc} function is safe for
use in signal handlers.  This may mean keeping an extra emergency
chunk to allocate when a new chunk is needed within a signal handler,
just to avoid calling @code{malloc} from the signal handler.
@end itemize

The same consideration applies to any of the functions that allocate
or grow objects.

Likewise, you can use @code{obstack_free} in a signal handler provided
you are sure that the interrupted program was not trying to allocate or
free in the same obstack, and provided you can dispose of freed chunks
without calling @code{free} immediately.  You may be able to save the
chunks in a chain and free them later when signal handling is over.

In a multi-threaded program, you must make certain that it never happens
that two threads simultaneously operate on the same obstack.  In addition,
since @code{malloc} and @code{free} are not reentrant, you must design
the @code{obstack_chunk_alloc} and @code{obstack_chunk_free} functions
to interlock so that only one of them can actually call @code{malloc} or
@code{free} at a given time.

@node Summary of Obstack Functions
@subsection Summary of Obstack Functions

Here is a summary of all the functions associated with obstacks.
Each takes the address of an obstack (@code{struct obstack *}) as its first
argument.

@table @code
@item obstack_init (@var{obstack_ptr})
Initialize use of an obstack.  @xref{Representation of Obstacks}.

@item obstack_alloc (@var{obstack_ptr}, @var{size})
Allocate an object of @var{size} uninitialized bytes.
@xref{Allocation in an Obstack}.

@item obstack_copy (@var{obstack_ptr}, @var{address}, @var{size})
Allocate an object of @var{size} bytes, with contents copied from
@var{address}.  @xref{Allocation in an Obstack}.

@item obstack_copy0 (@var{obstack_ptr}, @var{address}, @var{size})
Allocate an object of @var{size}+1 bytes, with @var{size} of them
copied from @var{address}, and a null character at the end.  @xref{Allocation
in an Obstack}.

@item obstack_free (@var{obstack_ptr}, @var{object})
Free @var{object} (and everything allocated more recently than
@var{object}).  @xref{Freeing Objects in an Obstack}.

@item obstack_blank (@var{obstack_ptr}, @var{size})
Add @var{size} uninitialized bytes to a growing object.
@xref{Growing Objects}.

@item obstack_grow (@var{obstack_ptr}, @var{address}, @var{size})
Add @var{size} bytes, copied from @var{address}, to a growing object.
@xref{Growing Objects}.

@item obstack_grow0 (@var{obstack_ptr}, @var{address}, @var{size})
Add @var{size} bytes, copied from @var{address}, to a growing object,
and then add another byte containing a null character.  @xref{Growing
Objects}.

@item obstack_1grow (@var{obstack_ptr}, @var{data_char})
Add one byte containing @var{data_char} to a growing object.
@xref{Growing Objects}.

@item obstack_finish (@var{obstack_ptr})
Finalize the object that is growing and return its permanent address.
@xref{Growing Objects}.

@item obstack_object_size (@var{obstack_ptr})
Get the size of the currently growing object.  @xref{Growing Objects}.

@item obstack_blank_fast (@var{obstack_ptr}, @var{size})
Add @var{size} uninitialized bytes to a growing object without checking
that there is enough room.  @xref{Extra Fast Growing Objects}.

@item obstack_1grow_fast (@var{obstack_ptr}, @var{data_char})
Add one byte containing @var{data_char} to a growing object without
checking that there is enough room.  @xref{Extra Fast Growing Objects}.

@item obstack_room (@var{obstack_ptr})
Get the amount of room now available for growing the current object.
@xref{Extra Fast Growing Objects}.

@item obstack_alignment_mask (@var{obstack_ptr})
The mask used for aligning the beginning of an object.  This is an
lvalue.  @xref{Alignment of Data in Obstacks}.

@item obstack_chunk_size (@var{obstack_ptr})
The size for allocating chunks.  This is an lvalue.  @xref{Obstack Chunks}.

@item obstack_base (@var{obstack_ptr})
Tentative starting address of the currently growing object.
@xref{Status of an Obstack}.

@item obstack_next_free (@var{obstack_ptr})
Address just after the end of the currently growing object.
@xref{Status of an Obstack}.
@end table

@node Automatic Storage with Variable Size
@section Automatic Storage with Variable Size
@cindex automatic freeing

The function @code{alloca} supports a kind of half-dynamic allocation in
which blocks are allocated dynamically but freed automatically.

Allocating a block with @code{alloca} is an explicit action; you can
allocate as many blocks as you wish, and compute the size at run time.  But
all the blocks are freed when you exit the function that @code{alloca} was
called from, just as if they were automatic variables declared in that
function.  There is no way to free the space explicitly.

The prototype for @code{alloca} is in @file{<stdlib.h>}.  This function
is a GNU extension.

@comment stdlib.h
@comment GNU, BSD
@deftypefun {void *} alloca (size_t @var{size});
The return value of @code{alloca} is the address of a block of @var{size}
bytes of storage, allocated in the stack frame of the calling function.
@end deftypefun

@menu
* Alloca Example::			Example of using @code{alloca}.
* Advantages of @code{alloca}::		Reasons to use @code{alloca}.
* Disadvantages of @code{alloca}::	Reasons to avoid @code{alloca}.
* GNU C Variable-Size Arrays::		Only in GNU C, here is an alternative
					 method of allocating dynamically and
					 freeing automatically.
@end menu

@node Alloca Example
@subsection Alloca Example

As an example of use of @code{alloca}, here is a function that opens a file
name made from concatenating two argument strings, and returns a file
descriptor or minus one signifying failure:

@example
int open2 (char *str1, char *str2, int flags, int mode)
@{
  char *name = (char *) alloca (strlen (str1) + strlen (str2) + 1);
  strcpy (name, str1);
  strcat (name, str2);
  return open (name, flags, mode);
@}
@end example

@noindent
Here is how you would get the same results with @code{malloc} and
@code{free}:

@example
int open2 (char *str1, char *str2, int flags, int mode)
@{
  char *name = (char *) malloc (strlen (str1) + strlen (str2) + 1);
  int desc;
  if (name == 0)
    fatal ("virtual memory exceeded");
  strcpy (name, str1);
  strcat (name, str2);
  desc = open (name, flags, mode);
  free (name);
  return desc;
@}
@end example

As you can see, it is simpler with @code{alloca}.  But @code{alloca} has
other, more important advantages, and some disadvantages.

@node Advantages of @code{alloca}
@subsection Advantages of @code{alloca}

Here are the reasons why @code{alloca} may be preferable to @code{malloc}:

@itemize @bullet
@item
Using @code{alloca} wastes very little space or time.

@item
Since @code{alloca} does not have separate pools for different sizes
of block, space used for any size block can be reused for any other
size.

@item
@cindex longjmp
Nonlocal exits done with @code{longjmp} (@pxref{Non-Local Exits})
automatically free the space allocated with @code{alloca} when they exit
through the function that called @code{alloca}.  This is the most
important reason to use @code{alloca}.

To illustrate this, suppose you have a function
@code{open_or_report_error} which returns a descriptor, like
@code{open}, if it succeeds, but does not return to its caller if it
fails.  If the file cannot be opened, it prints an error message and
jumps out to the command level of your program using @code{longjmp}.
Let's change @code{open2} (@pxref{Alloca Example}) to use this
subroutine:@refill

@example
int open2 (char *str1, char *str2, int flags, int mode)
@{
  char *name = (char *) alloca (strlen (str1) + strlen (str2) + 1);
  strcpy (name, str1);
  strcat (name, str2);
  return open_or_report_error (name, flags, mode);
@}
@end example

@noindent
Because of the way @code{alloca} works, the storage it allocates is
freed even when an error occurs, with no special effort required.

By contrast, the previous definition of @code{open2} (which uses
@code{malloc} and @code{free}) would develop a storage leak if it were
changed in this way.  Even if you are willing to make more changes to
fix it, there is no easy way to do so.
@end itemize

@node Disadvantages of @code{alloca}
@subsection Disadvantages of @code{alloca}
@cindex @code{alloca} disadvantages
@cindex disadvantages of @code{alloca}

These are the disadvantages of @code{alloca} in comparison with
@code{malloc}:

@itemize @bullet
@item
If you try to allocate more storage than the machine can provide, you
don't get a clean error message.  Instead you get a fatal signal like
the one you would get from an infinite recursion; probably a
segmentation violation.

@item
Some non-GNU systems fail to support @code{alloca}, so it is less
portable.  However, a slower emulation of @code{alloca} written in C
is available for use on systems with this deficiency.
@end itemize

@node GNU C Variable-Size Arrays
@subsection GNU C Variable-Size Arrays
@cindex variable-sized arrays

In GNU C, you can replace most uses of @code{alloca} with an array of
variable size.  Here is how @code{open2} would look then:

@example
int open2 (char *str1, char *str2, int flags, int mode)
@{
  char name[strlen (str1) + strlen (str2) + 1];
  strcpy (name, str1);
  strcat (name, str2);
  return open (name, flags, mode);
@}
@end example

But @code{alloca} is not always equivalent to a variable-sized array, for
several reasons:

@itemize @bullet
@item
A variable size array's space is freed at the end of the scope of the
name of the array.  The space allocated with @code{alloca} usually
remains until the end of the function.

@item
It is possible to use @code{alloca} within a loop, allocating an
additional block on each iteration.  This is impossible with
variable-sized arrays.  On the other hand, this is also slightly
unclean.
@end itemize

If you mix use of @code{alloca} and variable-sized arrays within one
function, exiting a scope in which a variable-sized array was declared
frees all blocks allocated with @code{alloca} during the execution of that
scope.


@node Relocating Allocator
@section Relocating Allocator

@strong{Incomplete:}  Information about the relocating storage allocator
used by Emacs 19 goes here.
