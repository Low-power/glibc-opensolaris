\input texinfo                  @c -*- Texinfo -*-
@comment %**start of header (This is for running Texinfo on a region.)
@setfilename library.info
@settitle The GNU C Library
@setchapternewpage odd
@comment %**end of header (This is for running Texinfo on a region.)

@ifinfo
This file documents the GNU C library.

Copyright (C) 1992 Free Software Foundation, Inc.

This will be free information when it is finished, but isn't finished yet.
@end ifinfo

@setchapternewpage odd

@titlepage
@center @titlefont{The GNU C Library}
@sp 1
@center @titlefont{Reference Manual}
@sp 2
@center Sandra Loosemore
@center with
@center Roland McGrath, Andrew Oram, and Richard M. Stallman
@sp 3
@center last updated January 10, 1992
@sp 1
@center for version 0.00
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1992 Free Software Foundation, Inc.
@end titlepage
@page

@ifinfo
@node Top, Introduction, (dir), (dir)
@top Main Menu
This is the reference manual for version 0.00 of the GNU C Library.
@end ifinfo


@menu
* Introduction::                Purpose of the GNU C Library.
* Error Reporting::             How the GNU Library functions report
					 error conditions.
* Memory Allocation::           Your program can allocate memory
					 dynamically and manipulate it via
					 pointers.
* Character Handling::          Character testing and conversion
					 functions.
* String and Array Utilities::  Utilities for copying and comparing
					 strings and arrays.
* Extended Characters::         Support for extended character sets.
* Locales::                     The country and language can affect
                                         the behavior of library functions.
* Searching and Sorting::       General searching and sorting
					 functions.
* I/O Overview::       Introduction to the i/o facilities.
* I/O on Streams::     High-level, portable i/o facilities.
* Low-Level I/O::      Low-level, less portable i/o.
* File System Interface::       Functions for manipulating files.
* Pipes and FIFOs::             A simple interprocess communication
					 mechanism.
* Sockets::                     A more complicated interprocess
					 communication mechanism, with support
					 for networking.
* Low-Level Terminal Interface::  How to change the characteristics
					 of a terminal device.
* Mathematics::                 Math functions (transcendental,
					  random numbers, abs value).
* Arithmetic::                  Low-level arithmetic functions.
* Date and Time::               Functions for getting the date and
					 time, and conversion between formats.
* Non-Local Exits::             The @code{setjmp} and @code{longjmp}
					 facilities.
* Signal Handling::             All about signals; how to send them,
					 block them, and handle them.
* Processes::                   How to create processes and run other
					 programs.
* Job Control::                 All about process groups and sessions.
* Users and Groups::            
* System Information::          Getting information about the
                                         hardware and software configuration
                                         of the machine a program runs on.
* System Configuration Limits::  Parameters describing operating
					 system limits.

Appendices
* Language Features::           C language features provided by the library. 

* Summary of Library Facilities::  A summary showing the syntax, header
                                         file, and derivation of each library
                                         feature.
* Maintenance::                 How to install and maintain the
                                         GNU C Library.
* Copying::                     The GNU Library General Public License
                                         says how you can copy and share the
                                         GNU C Library.

Indices
* Concept Index::               Index of concepts and names.
* Type Index::                  Index of types and type qualifiers.
* Function Index::              Index of functions and function-like macros.
* Variable Index::              Index of variables and variable-like macros.
* File Index::                  Index of programs and files.

 --- The Detailed Node Listing ---

Introduction

* Getting Started::             Getting Started
* Standards and Portability::   Standards and Portability
* Using the Library::           Using the Library
* Roadmap to the Manual::       Roadmap to the Manual

Standards and Portability

* ANSI C::                      The American National Standard for the
				 C programming language.  
* POSIX::                       The IEEE 1003 standards for operating systems.
* Berkeley Unix::               BSD and SunOS.
* SVID::                        The System V Interface Description.  

Using the Library

* Header Files::                How to include the header files in your programs.
* Macro Definitions::           Some functions in the library may really be 
			 implemented as macros.
* Reserved Names::              The C standard reserves some names for the library,
			 and some for users.
* Feature Test Macros::         How to control what names are defined.

Error Reporting

* Checking for Errors::         How errors are reported by library functions.
* Error Codes::                 Error Codes
* Error Messages::              Mapping error codes onto error messages.

Memory Allocation

* Memory Concepts::             An introduction to concepts and terminology.
* Dynamic Allocation and C::    How to get different kinds of allocation in C.
* Unconstrained Allocation::    The @code{malloc} facility allows fully general
		 		 dynamic allocation.
* Obstacks::                    Obstacks are less general than malloc
				 but more efficient and convenient.
* Variable Size Automatic::     Allocation of variable-sized blocks
				 of automatic storage that are freed when the
				 calling function returns.
* Relocating Allocator::        

Unconstrained Allocation

* Basic Allocation::            Simple use of @code{malloc}.
* Malloc Examples::             Examples of @code{malloc}.  @code{xmalloc}.
* Freeing after Malloc::        Use @code{free} to free a block you
				 got with @code{malloc}.
* Changing Block Size::         Use @code{realloc} to make a block
				 bigger or smaller.
* Allocating Cleared Space::    Use @code{calloc} to allocate a
				 block and clear it.
* Efficiency and Malloc::       Efficiency considerations in use of
				 these functions.
* Aligned Memory Blocks::       Allocating specially aligned memory:
				 @code{memalign} and @code{valloc}.
* Heap Consistency Checking::   Automatic checking for errors.
* Hooks for Malloc::            You can use these hooks for debugging
				 programs that use @code{malloc}.
* Statistics of Malloc::        Getting information about how much
				 memory your program is using.
* Summary of Malloc::           Summary of @code{malloc} and related functions.

Obstacks

* Representation of Obstacks::  How to declare an obstack in your
					 program.
* Preparing to Use Obstacks::   Preparations needed before you can
					 use obstacks.
* Allocation in an Obstack::    Allocating objects in an obstack.
* Freeing Obstack Objects::  Freeing objects in an obstack.
* Obstack Functions and Macros::  The obstack functions are both
					 functions and macros.
* Growing Objects::             Making an object bigger by stages.
* Extra Fast Growing Objects::  Extra-high-efficiency (though more
					 complicated) growing.
* Status of an Obstack::        Inquiries about the status of an
					 obstack.
* Obstacks Data Alignment::  Controlling alignment of objects
					 in obstacks.
* Obstack Chunks::              How obstacks obtain and release chunks.
					 Efficiency considerations.
* Obstacks and Signal Handling::  Don't try to use obstack functions
					 in a signal handler.
* Summary of Obstacks::         

Automatic Storage with Variable Size

* Alloca Example::              Example of using @code{alloca}.
* Advantages of Alloca::        Reasons to use @code{alloca}.
* Disadvantages of Alloca::     Reasons to avoid @code{alloca}.
* GNU C Variable-Size Arrays::  Only in GNU C, here is an alternative
					 method of allocating dynamically and
					 freeing automatically.

Character Handling

* Classification of Characters::  Testing whether characters are
					 letters, digits, punctuation, etc.
* Case Conversion::             Case mapping, and the like.

String and Array Utilities

* Representation of Strings::   Introduction to basic concepts.
* String/Array Conventions::    Whether to use a string function or an
				 arbitrary array function.
* String Length::               Determining the length of a string.
* Copying and Concatenation::   Functions to copy the contents of strings
				 and arrays.
* String/Array Comparison::     Functions for byte-wise and character-wise
				 comparison.
* Collation Functions::         Functions for collating strings.
* Search Functions::            Searching for a specific element or substring.
* Finding Tokens in a String::  Splitting a string into tokens by looking
				 for delimiters.

Extended Characters

* Extended Char Intro::         Multibyte codes versus wide characters.
* Locales and Extended Chars::  The locale selects the character codes.
* Multibyte Char Intro::        How multibyte codes are represented.
* Wide Char Intro::             How wide characters are represented.
* Wide String Conversion::      Converting wide strings to multibyte code
                                   and vice versa.
* Length of Char::              how many bytes make up one multibyte char.
* Converting One Char::         Converting a string character by character.
* Example of Conversion::       Example showing why converting 
				   one character at a time may be useful.
* Shift State::                 Multibyte codes with "shift characters".

Locales and Internationalization

* Effects of Locale::           Actions affected by the choice of locale.
* Choosing Locale::             How the user specifies a locale.
* Locale Categories::           Different purposes for which you can select a locale.
* Setting the Locale::          How a program specifies the locale library functions.
* Standard Locales::            Locale names available on all systems.
* Numeric Formatting::          How to format numbers according to the chosen locale.

Numeric Formatting

* General Numeric::             
* Currency Symbol::             
* Sign of Money Amount::        

Searching and Sorting 

* Comparison Functions::        Defining how to compare two objects.
				Since the sort and search facilities are
				general, you have to specify the ordering.
* Array Search Function::       The @code{bsearch} function.
* Array Sort Function::         The @code{qsort} function.
* Search/Sort Example::         An example program.

I/O Overview

* I/O Concepts::       Some basic information and terminology.
* File Names::                  How to refer to a file.

I/O Concepts

* Streams and File Descriptors::  The GNU Library provides two ways
					 to access the contents of files.
* File Position::               

File Names

* Directories::                 Directories contain entries for files.
* File Name Resolution::        A file name specifies how to look up a file.
* File Name Errors::            Error conditions relating to file names.
* File Name Portability::   

I/O on Streams

* Streams::                     About the data type representing a stream.
* Standard Streams::            Streams to the standard input and output 
                         devices are created for you.
* Opening Streams::             How to create a stream to talk to a file.
* Closing Streams::             Close a stream when you are finished with it.
* Simple Output::               Unformatted output by characters and lines.
* Character Input::             Unformatted input by characters and words.
* Line Input::                  Reading a line or a record from a stream.
* Unreading::                   Peeking ahead/pushing back input just read.
* Formatted Output::            @code{printf} and related functions.
* Customizing Printf::          You can define new conversion specifiers for
                         @code{printf} and friends.
* Formatted Input::             @code{scanf} and related functions.
* Block Input/Output::          Input and output operations on blocks of data.
* EOF and Errors::              How you can tell if an I/O error happens.
* Binary Streams::              Some systems distinguish between text files
                         and binary files.
* File Positioning::            About random-access streams.
* Portable Positioning::        Random access on peculiar ANSI C systems.
* Stream Buffering::            How to control buffering of streams.
* Temporary Files::             How to open a temporary file.
* Other Kinds of Streams::      Other Kinds of Streams

Unreading

* Unreading Idea::              An explanation of unreading with pictures.
* How Unread::                  How to call @code{ungetc} to do unreading.

Formatted Output

* Formatted Output Basics::     Some examples to get you started.
* Output Conversion Syntax::    General syntax of conversion
                                         specifications.
* Table of Output Conversions::  Summary of output conversions and
                                         what they do.
* Integer Conversions::         Details about formatting of integers.
* Floating-Point Conversions::  Details about formatting of
                                         floating-point numbers.
* Other Output Conversions::    Details about formatting of strings,
                                         characters, pointers, and the like.
* Formatted Output Functions::  Descriptions of the actual functions.
* Variable Arguments Output::  @code{vprintf} and friends.
* Parsing a Template String::   What kinds of args
                                         does a given template call for?

Customizing Printf

* Registering New Conversions::  
* Conversion Specifier Options::  
* Defining the Output Handler::  
* Printf Extension Example::    

Formatted Input

* Formatted Input Basics::      Some basics to get you started.
* Input Conversion Syntax::     Syntax of conversion specifications.
* Table of Input Conversions::  Summary of input conversions and what they do.
* Numeric Input Conversions::   Details of conversions for reading numbers.
* String Input Conversions::    Details of conversions for reading strings.
* Other Input Conversions::     Details of miscellaneous other conversions.
* Formatted Input Functions::   Descriptions of the actual functions.
* Variable Arguments Input::  @code{vscanf} and friends.

Stream Buffering

* Buffering Concepts::          Terminology is defined here.
* Flushing Buffers::            How to ensure that output buffers are flushed.
* Controlling Buffering::       How to specify what kind of buffering to use.

Other Kinds of Streams

* String Streams::              
* Custom Streams::              

Programming Your Own Custom Streams

* Streams and Cookies::         
* Hook Functions::              

Low-Level I/O

* Opening and Closing Files::   How to open and close file descriptors.
* I/O Primitives::              Reading and writing data.
* File Position Primitive::     Setting a descriptor's file position.
* Descriptors and Streams::     Converting descriptor to stream
                                         or vice-versa.
* Stream/Descriptor Precautions::  Precautions needed if you use both
                                         descriptors and streams.
* Waiting for I/O::             How to check for input or output
					 on multiple file descriptors.
* Control Operations::          Various other operations on file
					 descriptors.
* Duplicating Descriptors::     Fcntl commands for duplicating file
					 descriptors.
* Descriptor Flags::            Fcntl commands for manipulating flags
					 associated with file descriptors.
* File Status Flags::           Fcntl commands for manipulating flags
					 associated with open files.
* File Locks::                  Fcntl commands for implementing file
					 locking.
* Interrupt Input::             Getting an asynchronous signal when
                                         input arrives.

File System Interface

* Working Directory::           This is used to resolve relative
				 file names.
* Accessing Directories::       Finding out what files a directory
				 contains.
* Hard Links::                  Adding alternate names to a file.
* Symbolic Links::              A file that ``points to'' a file name.
* Deleting Files::              How to delete a file, and what that means.
* Renaming Files::              Changing a file's name.
* Creating Directories::        A system call just for creating a directory.
* File Attributes::             Attributes of individual files.
* Making Special Files::        How to create special files.

Accessing Directories

* Directory Entries::           Format of one directory entry.
* Opening a Directory::         How to open a directory stream.
* Reading/Closing Directory::   How to read directory entries from the stream.
* Simple Directory Lister::     A very simple directory listing program.
* Random Access Directory::     Rereading part of the directory
                                  already read with the same stream.

File Attributes

* Attribute Meanings::          The names of the file attributes, 
                           and what their values mean.
* Reading Attributes::          How to read the attributes of a file.
* Testing File Type::           Distinguishing ordinary files, directories, links...
* File Owner::                  How ownership for new files is determined,
			   and how to change it.
* Permission Bits::             How information about a file's access mode is stored.
* Access Permission::           How the system decides who can access a file.
* Setting Permissions::         How permissions for new files are assigned,
			   and how to change them.
* Testing File Access::         How to find out if your process can access a file.
* File Times::                  About the time attributes of a file.

Pipes and FIFOs

* Creating a Pipe::             Making a pipe with the @code{pipe} function.
* Pipe to a Subprocess::        Using a pipe to communicate with a
				 child process.
* FIFO Special Files::          Making a FIFO special file.

Sockets

* Socket Creation and Naming::  Functions for creating and
                                         initializing sockets.
* Domains and Protocols::       How to specify the communications
					 protocol for a socket.
* Local Domain::            Details about the local (Unix) domain.
* Internet Domain::         Details about the Internet domain.
* Types of Sockets::            Different socket types have different
					 semantics for data transmission.
* Byte Stream Sockets::  Operations on sockets with connection
					 state.
* Datagram Socket Operations::  Operations on datagram sockets.
* Socket Options::              Miscellaneous low-level socket options.

Socket Creation and Naming

* Creating a Socket::           How to open a socket.
* Closing a Socket::            How to close a socket.
* Socket Naming::               You must associate a name with a socket
					 before it can receive data.
* Socket Pairs::                These are created like pipes.

Internet Domain

* Protocols Database::          Selecting a communications protocol.
* Internet Socket Naming::      How socket names are specified in the Internet
                                 domain.
* Internet Host Addresses::     Hosts are assigned addresses that are numbers.
* Hosts Database::              A host may also have a symbolic host name.
* Services Database::           Ports may also have symbolic names.
* Networks Database::           There is also a database for network names.
* Byte Order Conversion::       Different hosts may use different byte
                                 ordering conventions; you need to canonicalize
                                 host address and port numbers.
* Internet Socket Example::     Putting it all together.

Byte Stream Sockets

* Establishing a Connection::   The socket must be connected before it
                                 can transmit data.
* Transferring Data::           How to send and receive data.
* Byte Stream Socket Example::  An example program.
* Out-of-Band Data::            This is an advanced feature.

Datagram Socket Operations

* Transmitting Datagrams::      Functions for sending and receiving messages
                                 on a datagram socket.
* Datagram Socket Example::     An example program.

Socket Options

* Socket Option Functions::     The basic functions for setting and getting
                                 socket options.
* Socket-Level Options::        Details of the options at the socket level.

Low-Level Terminal Interface

* Is It a Terminal::            How to determine if a file is a terminal
			  device, and what its name is.
* I/O Queues::                  About flow control and typeahead.
* Canonical or Not::            Two basic styles of input processing.
* Terminal Modes::              How to examine and modify flags controlling
			  details of terminal I/O: echoing, signals, editing.
* Line Control::                Sending break sequences, clearing terminal buffers...
* Noncanon Example::            How to read single characters without echo.

Terminal Modes

* Mode Data Types::             The data type @code{struct termios} and related types.
* Mode Functions::              Functions to read and set the terminal attributes.
* Setting Modes::               The right way to set terminal attributes reliably.
* Input Modes::                 Flags controlling low-level input handling.
* Output Modes::                Flags controlling low-level output handling.
* Control Modes::               Flags controlling serial port behavior.
* Local Modes::                 Flags controlling high-level input handling.
* Line Speed::                  How to read and set the terminal line speed.
* Special Characters::          Characters that have special effects,
			  and how to change them.
* Noncanonical Input::          Controlling how long to wait for input.

Special Characters

* Editing Characters::          
* Signal Characters::           
* Start/Stop Characters::       

Mathematics

* Domain and Range Errors::     How overflow conditions and the like
					 are reported.
* Not a Number::                Making NANs and testing for NANs.
* Trig Functions::     Sine, cosine, and tangent.
* Inverse Trig Functions::  Arc sine, arc cosine, and arc tangent.
* Exponents and Logarithms::  Also includes square root.
* Hyperbolic Functions::        Hyperbolic sine and friends.
* Pseudo-Random Numbers::       Functions for generating pseudo-random
					 numbers.
* Absolute Value::              Absolute value functions.

Pseudo-Random Numbers

* ANSI C Random Number Functions::  @code{rand} and friends.
* BSD Random Number Functions::  @code{random} and friends.

Low-Level Arithmetic Functions

* Normalization Functions::     Hacks for radix-2 representations.
* Rounding and Remainders::  Determinining the integer and
					 fractional parts of a float.
* Integer Division::            Functions for performing integer
					 division.
* Parsing of Numbers::          Functions for ``reading'' numbers
					 from strings.
* Predicates on Floats::        Some miscellaneous test functions.

Parsing of Numbers

* Parsing of Integers::         Functions for conversion of integer values.
* Parsing of Floats::           Functions for conversion of floating-point
				 values.

Date and Time

* Processor Time::              Measures processor time used by a program.
* Calendar Time::               Manipulation of ``real'' dates and times.
* Setting an Alarm::            Sending a signal after a specified time.
* Sleeping::                    Waiting for a period of time.

Processor Time

* Basic CPU Time::              The @code{clock} function.
* Detailed CPU Time::           The @code{times} function.

Calendar Time

* Simple Calendar Time::        Facilities for manipulating calendar time.
* High-Resolution Calendar::    A time representation with greater precision.
* Broken-down Time::            Facilities for manipulating local time.
* Formatting Date and Time::    Converting times to strings.
* TZ Variable::                 How users specify the time zone.
* TZ Functions::         Functions to examine or specify the time zone.
* Time Functions Example::      An example program showing use of some of
				 the time functions.

Non-Local Exits

* Intro to Non-Local Exits::  An overview of how and when to use
					 these facilities.
* Functions for Non-Local Exits::  Details of the interface.
* Non-Local Exits and Signals::  Portability issues.

Signal Handling

* Concepts of Signals::         Introduction to the signal facilities.
* Standard Signals::            Particular kinds of signals with standard
			     names and meanings.
* Signal Actions::              Specifying what happens when a particular signal
			     is delivered.
* Defining Handlers::           How to write a signal handler function.
* Generating Signals::          How to send a signal to a process.
* Blocking Signals::            Making the system hold signals temporarily.
* Waiting for a Signal::        Suspending your program until a signal arrives.
* BSD Signal Handling::         Additional functions for backward
			     compatibility with BSD.
* BSD Handler::                 BSD Function to Establish a Handler

Basic Concepts of Signals

* Kinds of Signals::            Some examples of what can cause a signal.
* Signal Generation::           Concepts of why and how signals occur.
* Delivery of Signal::          Concepts of what a signal does to the process.

Standard Signals

* Program Error Signals::       Used to report serious program errors.
* Termination Signals::         Used to interrupt and/or terminate the program.
* Alarm Signals::               Used to indicate expiration of timers.
* Asynchronous I/O Signals::    Used to indicate input is available.
* Job Control Signals::         Signals used to support job control.
* Miscellaneous Signals::       Miscellaneous Signals
* Other Signals::               Implementations can support other signals.
* Signal Messages::             Printing a message describing a signal.

Specifying Signal Actions

* Basic Signal Handling::       The simple @code{signal} function.
* Advanced Signal Handling::    The more powerful @code{sigaction} function.
* Signal and Sigaction::        How those two functions interact.
* Sigaction Function Example::  An example of using the sigaction function.
* Flags for Sigaction::         Specifying options for signal handling.
* Initial Signal Actions::      How programs inherit signal actions.

Defining Signal Handlers

* Handler Returns::             
* Termination in Handler::      
* Longjmp in Handler::          
* Signals in Succession::       
* Nonreentrancy::               
* Atomic Data Access::          

Generating Signals

* Signaling Yourself::          Signaling Yourself
* Signaling Another Process::   Send a signal to another process.
* Permission for kill::         Permission for using @code{kill}
* Kill Example::                Using @code{kill} for Communication

Blocking Signals

* Why Block::                   The purpose of blocking signals.
* Signal Sets::                 How to specify which signals to block.
* Process Signal Mask::         Blocking delivery of signals to your
					 process during normal execution.
* Testing for Delivery::        Blocking to Test for Delivery of a Signal
* Blocking for Handler::        Blocking additional signals while a
					 handler is being run.
* Checking for Pending Signals::  Checking for Pending Signals
* Remembering a Signal::        How you can get almost the same effect
				 as blocking a signal, by handling it
				 and setting a flag to be tested later.

Waiting for a Signal

* Using Pause::                 The simple way, using @code{pause}.
* Pause Problems::              Why the simple way is often not very good.
* Sigsuspend::                  Reliably waiting for a specific signal.

BSD Signal Handling

* POSIX vs BSD::                Overview comparing BSD and POSIX signal functions.

BSD Function to Establish a Handler

* Blocking in BSD::             BSD Functions for Blocking Signals 
* Signal Stack::                Using a Separate Signal Stack

Processes

* Program Arguments::           Parsing the command-line arguments to
				 a program.
* Environment Variables::       How to access parameters inherited from
				 a parent process.
* Program Termination::         How to cause a process to terminate and
				 return status information to its parent.
* Creating New Processes::      Running other programs.

Program Arguments

* Argument Syntax Conventions::  By convention, program
                                                 options are specified by a
                                                 leading hyphen.
* Parsing Program Arguments::   The @code{getopt} function.
* Example Using getopt::  An example of @code{getopt}.

Environment Variables

* Environment Access::          How to get and set the values of
					 environment variables.
* Standard Environment Variables::  These environment variables have
					 standard interpretations.

Program Termination

* Normal Program Termination::  
* Exit Status::                 Exit Status
* Cleanups on Exit::            Cleanups on Exit
* Aborting a Program::          
* Termination Internals::       Termination Internals

Creating New Processes

* Running a Command::           The easy way to run another program.
* Process Creation Concepts::   An overview of the hard way to do it.
* Process Identification::      How to get the process ID of a process.
* Creating a Process::          How to fork a child process.
* Executing a File::            How to get a process to execute another
				         program.
* Process Completion::          How to tell when a child process has
				         completed.
* Process Completion Status::   How to interpret the status value 
                                         returned from a child process.
* BSD wait Functions::  More functions, for backward
                                         compatibility.
* Process Creation Example::    A complete example program.

Job Control

* Concepts of Job Control ::    Concepts of Job Control
* Job Control is Optional::     Not all POSIX systems support job control.
* Controlling Terminal::        How a process gets its controlling terminal.
* Access to the Terminal::      How processes share the controlling terminal.
* Orphaned Process Groups::     Jobs left after the user logs out.
* Implementing a Shell::        What a shell must do to implement job control.
* Functions for Job Control::   Functions to control process groups.

Implementing a Job Control Shell

* Data Structures::             Introduction to the sample shell.
* Initializing the Shell::      What the shell must do to take
				 responsibility for job control.
* Launching Jobs::              Creating jobs to execute commands.
* Foreground and Background::   Putting a job in foreground of background.
* Stopped and Terminated Jobs::  Reporting job status.
* Continuing Stopped Jobs::     How to continue a stopped job in
				 the foreground or background.
* Missing Pieces::          Other parts of the shell.

Functions for Job Control

* Identifying the Terminal::    Determining the controlling terminal's name.
* Process Group Functions::     Functions for manipulating process groups.
* Terminal Access Functions::   Functions for controlling terminal access.

Users and Groups

* User and Group IDs::          Each user has a unique numeric ID; likewise for groups.
* Process Persona::             The user IDs and group IDs of a process.
* Why Change Persona::          Why a program might need to change
			 its user and/or group IDs.
* How Change Persona::          Restrictions on changing the user and group IDs.
* Reading Persona::             How to examine the process's user and group IDs.
* Setting User ID::             
* Setting Groups::              
* Enable/Disable Setuid::       
* Setuid Program Example::      Setuid Program Example
* Tips for Setuid::             
* Who Logged In::               Getting the name of the user who logged in,
			 or of the real user ID of the current process.

* User Database::               Functions and data structures for
                         accessing the user database.
* Group Database::              Functions and data structures for
                         accessing the group database.
* Database Example::            Example program showing use of database
			 inquiry functions.

User Database

* User Data Structure::         
* Lookup User::                 
* Scanning All Users::          Scanning the List of All Users
* Writing a User Entry::        

Group Database

* Group Data Structure::        
* Lookup Group::                
* Scanning All Groups::         Scanning the List of All Groups

System Information

* Host Identification::         Determining the name of the
                                                 machine.
* Hardware/Software Type ID::  Determining the hardware type
                                                 of the machine and what
                                                 operating system it is
                                                 running.

System Configuration Limits

* File System Parameters::      Constants and functions that describe
				 various file system limits.

* System Parameters::           Constants and functions that describe
				 various process-related limits.

* String-Valued Parameters::    Constants and functions that describe
				 string-valued limits.

Library Facilities that are Part of the C Language

* Consistency Checking::        Using @code{assert} to abort
				if something ``impossible'' happens.
* Variadic Functions::          Defining functions with varying numbers of args.
* Null Pointer Constant::       The macro @code{NULL}.
* Important Data Types::        Data types for object sizes.
* Data Type Measurements::      Parameters of data type representations.

Variadic Functions

* Why Variadic::                Reasons for making functions take variable arguments.
* How Variadic::                How to define and call variadic functions.
* Argument Macros::             Detailed specification of the macros
			   for accessing variable arguments.
* Variadic Example::            A complete example.

How Variadic Functions are Defined and Used

* Variadic Prototypes::         How to make a prototype for a function
				   with variable arguments.
* Receiving Argument Values::   Steps you must follow to access the
				   optional argument values.
* How Many Arguments::          How to decide whether there are more arguments.
* Calling Variadic Functions::  Things you need to know about calling
				   variable arguments functions.

Data Type Measurements

* Integer Type Macros::         Parameters that measure the integer types.
* Floating Type Macros::        Parameters that measure the floating point types.
* Structure Measurement::       Getting measurements on structure types.

Floating Type Macros

* Floating Point Concepts::     Definitions of terminology.
* Floating-Point Parameters::   Floating-Point Parameters
* IEEE Floating Point::         How one common representation is described.

Library Maintenance

* Installation::                How to configure, compile and install
                			 the GNU C library.
* Reporting Bugs::              How to report bugs (if you want to
                                         get them fixed) and other troubles
                                         you may have with the GNU C library.
* Porting::                     How to port the GNU C library to
                                         a new machine or operating system.
* Traditional C Compatibility::  Using the GNU C library with non-ANSI
                                         C compilers.
* GNU C Library Contributors::  Contributors to the GNU C Library.

Porting the GNU C Library

* Hierarchy Conventions::       How the @file{sysdeps} hierarchy is
                                 layed out.
* Porting to Unix::             Porting the library to an average
                                 Unix-like system.
@end menu



@include intro.texinfo
@include errno.texinfo
@include memory.texinfo
@include ctype.texinfo
@include string.texinfo
@include mbyte.texinfo
@include locale.texinfo
@include search.texinfo
@include io.texinfo
@include stdio.texinfo
@include llio.texinfo
@include filesys.texinfo
@include pipe.texinfo
@include socket.texinfo
@include terminal.texinfo
@include math.texinfo
@include arith.texinfo
@include time.texinfo
@include setjmp.texinfo
@include signal.texinfo
@include process.texinfo
@include job.texinfo
@include users.texinfo
@include sysinfo.texinfo
@include conf.texinfo
@include lang.texinfo

@include header.texinfo
@include maint.texinfo

@c @set lgpl-appendix
@c node Copying, Concept Index, Maintenance, Top
@c @include lgpl.texinfo
@include copying.texinfo

@include index-cp.texi

@include index-tp.texi
   
@include index-fn.texi

@include index-vr.texi

@include index-pg.texi

@shortcontents
@contents
@bye
