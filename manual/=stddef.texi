@node Common Definitions
@chapter Common Definitions - @file{<stddef.h>}
@pindex <stddef.h>

There are some miscellaneous data types and macros that are not part of
the C language kernel but are nonetheless almost universally used, such
as the macro @code{NULL}.  In order to use these type and macro
definitions, your program should include the header file
@file{<stddef.h>}.

@deftp {Data Type} ptrdiff_t
This is the signed integer type of the result of subtracting two
pointers.  For example, with the declaration @code{char *p1, *p2;}, the
expression @code{p2 - p1} is of type @code{ptrdiff_t}.  This will
probably be one of the standard signed integer types (@code{short int},
@code{int} or @code{long int}), but might be a nonstandard type that
exists only for this purpose.
@end deftp

@deftp {Data Type} size_t
This is an unsigned integer type used to represent the sizes of objects.
The result of the @code{sizeof} operator is of this type, and functions
such as @code{malloc} (@pxref{Unconstrained Allocation}) and
@code{memcpy} (@pxref{Copying and Concatenation}) that manipulate
objects of arbitrary sizes accept arguments of this type to specify
object sizes.
@end deftp

As a general concern with derived data types such as these, you need to
be careful either to consistently declare variables and function
prototypes that can receive values of these types with the derived
types, or else to use an explicit cast on the value.  For example, you
shouldn't use @code{size_t} interchangably either with @code{unsigned
int} or @code{unsigned long int}, since it might be either; this is a
particular problem when passing values to functions for which there is
no prototype declared in scope, since the default argument promotions
can differ from implementation to implementation.  Another problem is
that there aren't any constants in @file{<limits.h>} to tell you what
the minimum and maximum values for these data types are.

@strong{Compatibility Note:}  Types such as @code{size_t} are new
features of ANSI C.  Older, pre-ANSI C implementations have
traditionally used @code{unsigned int} for representing object sizes,
@code{int} for pointer subtraction results, and don't have any notion
at all of wide characters.

@defvr {Macro} NULL
@cindex null pointer
This is a null pointer constant.  It can be assigned to any pointer
variable since it has type @code {void *}, and is guaranteed not to
point to any real object.  This macro is the best way to get a null
pointer value.  You can also use @code{0} or @code{(void *)0} as a null
pointer constant, but using @code{NULL} makes the purpose of the
constant more evident.  

When passing a null pointer as an argument to a function for which there
is no prototype declaration in scope, you should explicitly cast
@code{NULL} or @code{0} into a pointer of the appropriate type.  (This
is because, in some implementations, pointers to different types of
objects might have different sizes.)  For example, to pass a null
pointer to a function expecting a pointer to @code{int}, you should use
@code{((int *) NULL)} or @code{((int *) 0)}.
@refill
@end defvr

@deftypefn {Macro} size_t offsetof (@var{type}, @var{member})
This expands to a integer constant expression that is the offset of the
structure member named @var{member} in a @code{struct} of type
@var{type}.  For example, @code{offsetof (struct s, elem)} is the offset,
in bytes, of the member @code{elem} in a @code{struct s}.  This macro
cannot be used to determine the offset of a bit field.
@refill
@end deftypefn
