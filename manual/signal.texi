@node Signal Handling
@chapter Signal Handling

@cindex signal
A @dfn{signal} can be considered a software interrupt.  They are used by
the operating system to report information about exceptional situations
to an executing program.

The GNU C library defines a variety of signal types to handle program
errors and other system events that affect the behavior of your program.
Most of these events make it inadvisable or impossible for the program
to proceed as usual, and therefore normally cause the kernel to abort
the program.

If you can anticipate the events that cause signals, you can trap them
and override their default effects.  You can write a signal handler and
tell the operating system to run it when a particular type of signal
arrives.  Finally, you can send a signal to another process; this allows
parent process to abort a child, or two related processes to communicate
and synchronize.

@menu
* Signal Concepts::		Introduction to the signal facilities.
* Signal Names::		What the standard signals are and when
				 they happen.
* Specifying Signal Actions::	How to override the default behavior
				 for a signal.
* Defining a Signal Handler::	How to write a signal handler function.
* Generating Signals::     	How to send a signal to a process.
* Blocking Signals::		Making the system hold signals temporarily.
* Waiting for a Signal::	Suspending your program until a signal arrives.
* BSD Signal Handling::		Additional functions for backward
				 compatibility with BSD.
@end menu


@node Signal Concepts
@section Signal Concepts

Common events that generate signals include:

@itemize @bullet
@item
A program error such as dividing by zero or issuing an address outside
the valid range.

@item
A user request to interrupt or terminate the program.  Most environments
are set up to let a user suspend the program by typing @kbd{C-z}, or
terminate it with @kbd{C-c}.  Whatever key sequence is used, the
operating system sends the proper signal to interrupt the process.

@item
The termination of a child process.

@item
A @code{kill} call from another process.  Signals are a limited but
useful form of interprocess communication.

@item
Expiration of a timer or alarm.
@end itemize

There are different kinds of signals defined to indicate each of these
situations.  These are described in more detail in @ref{Signal Names}.

You can tell the process to ignore the signal, or tell it to call a
function you provide when the signal is delivered.  In the latter case,
it is said that the signal is @dfn{trapped} or @dfn{caught} by the
handler.  For more details about how to specify actions to take when a
signal arrives, @pxref{Specifying Signal Actions}.  
@cindex trapping signals
@cindex catching signals

The default action taken by a process when it receives most signals is
to terminate the process.  When this happens, its parent process can
detect the situation by examining the termination status code reported
by the @code{wait} or @code{waitpid} functions.  (This is discussed in
more detail in @ref{Process Completion}.)  If a program you run from a
shell is terminated by a signal, the shell typically provides some kind
of error message.

When a signal is @dfn{generated}, it is normally @dfn{delivered} to the
process immediately.  However, you can @dfn{block} or delay delivery of
signals.  If the action for a particular signal is something other than
to ignore it, when a signal of that type is generated it remains
@dfn{pending} until it is either unblocked (in which case it will be
delivered to the process) or its action is set to be ignored (causing it
to be discarded).  Signals that are ignored may be discarded immediately
if they are blocked.  The facilities for controlling blocking of signals
are discussed in @ref{Blocking Signals}.
@cindex generation of signals
@cindex delivery of signals
@cindex pending signals
@cindex blocked signals

@node Signal Names
@section Signal Names
@cindex signal names

Symbolic names for the various kinds of signals are defined in the
header file @file{signal.h}.  Each is a macro wich standars for a
positive integer.  This section describes what conditions these signals
are used for.
@pindex signal.h

@comment signal.h
@comment GNU
@deftypevr Macro int NSIG
The value of this symbolic constant is the total number of signals
defined.
@end deftypevr

@menu
* Program Error Signals::	Used to report serious program errors.
* Termination Signals::		Used to interrupt and/or terminate the program.
* Alarm Signals::		Used to indicate expiration of timers.
* Asynchronous I/O Signals::    Used to indicate input is available.
* Miscellanous Signals::	Used to report various random conditions.
* Job Control Signals:: 	Signals used to support job control.
* Other Signals::		Implementations can support other signals.
* Signal Messages::		Printing a message describing a signal.
@end menu

@node Program Error Signals
@subsection Program Error Signals
@cindex program error signals

The following signals are generated when a serious program error is
detected by the operating system or the computer itself.  In general,
all of these signals are indications that your program is seriously
broken in some way, and there's usually not much you can do to recover
from these conditions.

The default action for all of these signals is to cause the process to
terminate.  If you block or ignore these signals or establish a handler
for them that returns normally, your program will probably break
horribly unless the signals were generated by @code{raise} or
@code{kill} instead of a real program bug.

@comment signal.h
@comment ANSI
@deftypevr Macro int SIGFPE
The @code{SIGFPE} signal reports a fatal arithmetic error.  Although the
name is derived from ``floating-point exception'', this signal actually
covers all arithmetic errors, including division by zero and overflow.
If your program gets mixed up and stores integer data in a location
which is then used in a floating-point operation, you often get an
``invalid operation'' exception, because the processor cannot recognize
the data as a floating-point number.
@cindex exception
@cindex floating-point exception

Floating-point exceptions are a complicated subject because there are
many types of exceptions with subtly different meanings, and the
@code{SIGFPE} signal doesn't distinguish between them.  The @cite{IEEE
Standard for Binary Floating-Point Arithmetic (ANSI/IEEE Std 754-1985)}
defines various floating-point exceptions and requires conforming
computer systems to report their occurrences.  However, this standard
does not specify how the exceptions are reported, or what kinds of
handling and control the operating system can offer to the programmer.
If you're writing a library of numeric routines that has to be able to
trap and deal with the different kinds of exceptions intelligently,
you'll have to look at the documentation for your specific computer and
operating system to find out how.
@end deftypevr

@comment signal.h
@comment ANSI
@deftypevr Macro int SIGILL
The name of this signal is derived from ``illegal instruction''; it
means your program is trying to execute garbage or a privileged
instruction.  In a C program, this typically indicates that the
executable file is corrupted, or that you are trying to execute data.
Some common ways of getting into the latter situation are by passing an
invalid object where a pointer to a function was expected, or by writing
past the end of an automatic array (or similar problems with pointers to
automatic variables) and corrupting control information on the stack,
like a return address from a function call.
@end deftypevr
@cindex illegal instruction

@comment signal.h
@comment ANSI
@deftypevr Macro int SIGSEGV
This signal is generated when a program tries to read or write outside
the memory that is allocated for it.  (Actually, the signals only occur
when the program goes far enough outside to be detected by the system's
memory protection mechanism.)  The name is an abbreviation for ``segmentation
violation''.

The most common way of getting a @code{SIGSEGV} condition is by
dereferencing a null or uninitialized pointer.  Another typical way of
getting into a @code{SIGSEGV} situation is when you use a pointer to
step through an array, but fail to check for the end of the array.
@end deftypevr
@cindex segmentation violation

@comment signal.h
@comment BSD
@deftypevr Macro int SIGBUS
This signal is generated when an invalid pointer is dereferenced.  Like
@code{SIGSEGV}, this signal is typically the result of dereferencing an
uninitialized pointer.  The difference between the two is that
@code{SIGSEGV} indicates an invalid access to valid memory, while
@code{SIGBUS} indicates an access to an invalid address.  In particular,
@code{SIGBUS} signals often result from dereferencing a misaligned
pointer.

The name of this signal is an abbreviation for ``bus error''.
@end deftypevr
@cindex bus error


@node Termination Signals
@subsection Termination Signals
@cindex program termination signals

These signals are all used to tell a process to terminate, in one way
or another.  They have different names because they're used for slightly
different purposes, and you might want to establish different actions
for each one.

The (obvious) default action for all of these signals is to cause the
process to terminate.

@comment RMS was confused and thought SIGABRT was the same as SIGILL,
@comment and wanted its description moved into the previous node.  But
@comment is *not* the same as SIGILL -- it's the same as SIGIOT, which
@comment is one of those hardware-specific signals we don't discuss in
@comment detail.  So I've left SIGABRT here.

@comment signal.h
@comment ANSI
@deftypevr Macro int SIGABRT
This signal indicates an error detected by the program itself, which
causes abnormal program termination.  The @code{abort} function
(@xref{Aborting a Program}) generates this signal.
@end deftypevr
@cindex abort signal

@comment signal.h
@comment POSIX.1
@deftypevr Macro int SIGHUP
The @code{SIGHUP} (``hang-up'') signal is used to report that the user's
terminal is disconnected, perhaps because a network or telephone
connection was broken.  For more information about this, @pxref{Control
Modes}.

This signal is also used to report the termination of the controlling
process on a terminal to jobs associated with that session; in effect,
this reports that a process has been disconnected from its controlling
terminal.  For more information, @pxref{Process Termination Details}.
@end deftypevr
@cindex hangup signal

@comment signal.h
@comment ANSI
@deftypevr Macro int SIGINT
The @code{SIGINT} (``program interrupt'') signal is sent when the user
types the INTR character (normally @kbd{C-c}).  @xref{Special
Characters}, for information about terminal driver support.

You might want to establish a handler for this signal in order to make
your program terminate cleanly, performing whatever tidying-up actions
are appropriate first.  For example, you might want to write out state
information to a file, release locks on resources, and the like.
@end deftypevr
@cindex interrupt signal

@comment signal.h
@comment POSIX.1
@deftypevr Macro int SIGQUIT
The @code{SIGQUIT} signal is similar to @code{SIGINT}, except that it's
controlled by a different key --- the QUIT character, usually @kbd{C-\}
--- and produces a core dump when it terminates the process.
@xref{Special Characters}, for information about terminal driver
support.
@end deftypevr
@cindex quit signal

@comment signal.h
@comment POSIX.1
@deftypevr Macro int SIGKILL
The @code{SIGKILL} signal is used to cause immediate program termination.
It cannot be caught or ignored, and is therefore always fatal.  It is
also not possible to block this signal.

This signal occurs only on explicit request by a user program.  You would
use it when you want to immediately terminate a program.  For example, if
a process is not responding to any other termination signals, sending it
a @code{SIGKILL} signal will almost always cause it to go away.
@end deftypevr
@cindex kill signal

@comment signal.h
@comment ANSI
@deftypevr Macro int SIGTERM
The @code{SIGTERM} signal is a generic signal used to cause program
termination.  Unlike @code{SIGKILL}, this signal can be blocked, caught,
or ignored.

The shell command @code{kill} generates @code{SIGTERM} by default.
@pindex kill
@end deftypevr
@cindex termination signal


@node Alarm Signals
@subsection Alarm Signals

These signals are used to indicate the expiration of timers.
@xref{Setting an Alarm}, for information about functions that cause
these signals to be sent.

The default behavior for these signals is to cause program termination
--- not a very useful default, but we are stuck with it.  If you want to
use these signals, you should normally provide a signal handler.

@comment signal.h
@comment POSIX.1
@deftypevr Macro int SIGALRM
This signal typically indicates expiration of a timer that
measures real or clock time.  It is used by the @code{alarm} function,
for example.
@end deftypevr
@cindex alarm signal

@comment signal.h
@comment BSD
@deftypevr Macro int SIGVTALRM
This signal typically indicates expiration of a timer that measures CPU
time used by the current process.  The name is an abbreviation for
``virtual time alarm''.
@end deftypevr
@cindex virtual time alarm signal

@comment signal.h
@comment BSD
@deftypevr Macro int SIGPROF
This signal is typically indicates expiration of a timer that measures
both CPU time used by the current process, and CPU time expended on 
behalf of the process by the system.  Such a timer is used to implement
code profiling facilities, hence the name of this signal.
@end deftypevr
@cindex profiling alarm signal


@node Asynchronous I/O Signals
@subsection Asynchronous I/O Signals

The signals listed in this section are used in conjunction with
asynchronous I/O facilities.  You have to take explicit action by
calling @code{fcntl} to enable delivery of these signals by the
operating system; @pxref{Interrupt Input}.  The default action for these
signals is to ignore them.

@comment signal.h
@comment BSD
@deftypevr Macro int SIGIO
This signal is sent when a file descriptor is ready to perform input
or output.
@end deftypevr
@cindex input/output signal

@comment signal.h
@comment BSD
@deftypevr Macro int SIGURG
This signal is sent when ``urgent'' or out-of-band data arrives on a
socket.  @xref{Out-of-Band Data}.
@end deftypevr
@cindex urgent data signal


@node Miscellaneous Signals
@subsection Miscellaneous Signals

These signals are used to report various other conditions.  The default
action for all of them is to cause the process to terminate.

@comment signal.h
@comment POSIX.1
@deftypevr Macro int SIGPIPE
If you use pipes or FIFO special files, you have to design your
application so that one process opens the pipe for reading before
another starts writing.  If the reading process never starts, or
terminates unexpectedly, a write to the pipe or FIFO causes the writing
process to receive a @code{SIGPIPE} signal.

Pipes and FIFO special files are discussed in more detail in @ref{Pipes
and FIFOs}.
@end deftypevr
@cindex pipe signal
@cindex broken pipe signal

@comment signal.h
@comment POSIX.1
@deftypevr Macro int SIGUSR1
@end deftypevr
@comment signal.h
@comment POSIX.1
@deftypevr Macro int SIGUSR2
The @code{SIGUSR1} and @code{SIGUSR2} signals are set aside for you to
use any way you want.  They're useful for interprocess communication.
Since these signals are normally fatal, you should write a signal handler
for them in the program that receives the signal.

There is an example showing the use of @code{SIGUSR1} and @code{SIGUSR2}
in @ref{Signaling Another Process}.
@end deftypevr
@cindex user signals


@node Job Control Signals
@subsection Job Control Signals
@cindex job control signals

These signals are used to support job control.  If your system
doesn't support job control, then these macros are defined but the
signals themselves can't be raised or caught.

You should generally leave these signals alone unless you really
understand how job control works.  @xref{Job Control}.

@comment signal.h
@comment POSIX.1
@deftypevr Macro int SIGCHLD
This signal is sent to a parent process whenever one of its child
processes terminates or stops.

The default behavior for this signal is for it to be ignored.  If
you establish a handler for this signal while there are child processes
that have terminated but not reported their status via @code{wait} or
@code{waitpid} (@pxref{Process Completion}), whether
your new handler applies to those processes or not depends on the
particular operating system.
@end deftypevr
@cindex child process signal

@comment signal.h
@comment POSIX.1
@deftypevr Macro int SIGCONT
You can send a @code{SIGCONT} signal to a process to make it continue.
The default behavior for this signal is to make the process continue if
it is stopped, and for it to be ignored otherwise.
@end deftypevr
@cindex continue signal

@comment signal.h
@comment POSIX.1
@deftypevr Macro int SIGSTOP
The @code{SIGSTOP} signal stops the process.  It cannot be caught or
ignored.
@end deftypevr
@cindex stop signal

@comment signal.h
@comment POSIX.1
@deftypevr Macro int SIGTSTP
The @code{SIGTSTP} signal is an interactive stop signal.  Unlike
@code{SIGSTOP}, this signal can be caught or ignored.  Typically, you
trap this signal only if you have a special need to leave files or
system tables in a secure state when a process is stopped.

This signal is generated when the user types the SUSP character
(normally @kbd{C-z}).  For more information about terminal driver
support, @pxref{Special Characters}.
@end deftypevr
@cindex interactive stop signal

@comment signal.h
@comment POSIX.1
@deftypevr Macro int SIGTTIN
A process cannot read from the the user's terminal while it is running 
as a background job.  When any process in a background job tries to
read from the terminal, all of the processes in the job are sent a
@code{SIGTTIN} signal.  The default action for this signal is to
stop the process.  For more information about how this interacts with
the terminal driver, @pxref{Access to the Controlling Terminal}.
@end deftypevr
@cindex terminal input signal

@comment signal.h
@comment POSIX.1
@deftypevr Macro int SIGTTOU
This is similar to @code{SIGTTIN}, but is used when a process in a
background job attempts to write to the terminal.  Again, the default
action is to stop the process.
@end deftypevr
@cindex terminal output signal

While a process is stopped, no more signals can be delivered to it until
it is continued, except @code{SIGKILL} signals and (obviously)
@code{SIGCONT} signals.  The @code{SIGKILL} signal always causes
termination of the process and can't be blocked or ignored.  You can
block or ignore @code{SIGCONT}, but it always causes the process to
be continued anyway if it is stopped.  Sending a @code{SIGCONT} signal
to a process causes any pending stop signals for that process to be
discarded.  Likewise, any pending @code{SIGCONT} signals for a process
are discarded when it receives a stop signal.

The default action for a process that is a member of an orphaned
process group (@pxref{Process Termination Details}) that receives a
@code{SIGTSTP}, @code{SIGTTIN}, or @code{SIGTTOU} signal is not to stop
the process.  This makes sense; if a process is stopped by one of these
signals, it must be continued by the shell, and if a process group has
been orphaned, that means there's no shell around to continue the
processes.  Instead, the signal might be ignored, or the operating
system might turn the stop signal into another signal like @code{SIGHUP}.

@strong{Incomplete:}  What does the GNU system do?


@node Other Signals
@subsection Other Signals

@comment RMS flamed about this section, saying that ANSI signals should not
@comment be differentiated from non-ANSI signals.  But the purpose of
@comment this section is not to list non-ANSI signals (many of which are
@comment already listed in the appropriate sections above).  The purpose
@comment of this section is to warn users that there may be other signals 
@comment that are not supported on all hardware types.  According to mib
@comment and roland, the GNU system will not support all of the signals 
@comment listed in the BSD header files, for example.

Individual operating systems might support additional signals.  The ANSI
C standard reserves all identifiers beginning with @samp{SIG} followed
by an uppercase letter for the names of signals.  You should consult the
documentation or header files for your particular operating system and
processor type to find out about the specific signals it supports.

For example, some implementations support extra signals which correspond
to hardware traps.  Some other kinds of signals commonly supported are
used to implement limits on CPU time or file system usage, asynchronous
changes to terminal configuration, and the like.  And, an implementation
might define some signal names that are just synonyms for other signals.

You can generally assume that the default action (or the action set up
by the shell) for implementation-defined signals is reasonable, and not
worry about them yourself.  In fact, it's really a bad idea to ignore or
block signals you don't know anything about, or try to establish some
catch-all handler to take care of all random signals delivered to your
program.

@strong{Incomplete:}  The other signals listed are:

@table @code
@item SIGCLD
Obsolete name for @code{SIGCHLD}.

@item SIGTRAP
Generated by the machine's breakpoint instruction.  Used by debuggers.
Default action is to dump core.

@item SIGIOT
Generated by the PDP-11 ``iot'' instruction; equivalent to @code{SIGABRT}.
Default action is to dump core.

@item SIGEMT
Emulator trap, such as when you execute an unsupported instruction.
Default action is to dump core.

@item SIGSYS
Bad system call.
Default action is to dump core.

@item SIGPOLL
This is a System V thing, more or less equivalent to @code{SIGIO}.

@item SIGXCPU
CPU time limit exceeded.
Default action is program termination.

@item SIGXFSZ
File size limit exceeded.
Default action is program termination.

@item SIGWINCH
Window size change.  Sent by the system in response to @code{TIOCSWINSZ}
ioctl.
Default action is to ignore it.
@end table


@node Signal Messages
@subsection Signal Messages
@cindex signal messages

You can use the @code{strsignal} and @code{psignal} functions to get or
print a message string describing a signal.  The prototype for
@code{strsignal} is in @file{string.h}, and that for @code{psignal} in
@file{stdio.h}.
@pindex stdio.h
@pindex string.h

@comment string.h
@comment GNU
@deftypefun {char *} strsignal (int @var{signum})
This function returns a pointer to a statically-allocated string
containing a message describing the signal @var{signum}.  You
should not modify the contents of this string; and, since it can be
rewritten on subsequent calls, you should save a copy of it if you need
to reference it later.
@end deftypefun

@comment stdio.h
@comment GNU
@deftypefun void psignal (int @var{signum}, const char *@var{message})
This function prints a message describing the signal @var{signum}
to the stream @code{stderr}; @pxref{Standard Streams}.

If you call @code{psignal} with a @var{message} that is either a null
pointer or an empty string, @code{psignal} just prints the message 
corresponding to @var{signum}, adding a trailing newline.

If you supply a non-null @var{message} argument, then @code{psignal}
prefixes its output with this string.  It adds a colon and a space 
character to separate the @var{message} from the string corresponding
to @var{signum}.
@end deftypefun


@node Specifying Signal Actions
@section Specifying Signal Actions
@cindex signal actions

The simplest way to change the default action for a signal is to use the
@code{signal} function.  The GNU library also implements the more
complicated @code{sigaction} facility.  This section describes both
facilities and gives suggestions on which to use when.

@strong{Incomplete:}  RMS suggests putting an example here.

@menu
* Basic Signal Handling::	The simple @code{signal} function.
* Advanced Signal Handling::	The more powerful @code{sigaction} function.
* Sigaction Function Example::	An example of using the sigaction function.
* Sigaction Flags::		Specifying options for signal handling.
* Initial Signal Actions::	How programs inherit signal actions.
@end menu

@node Basic Signal Handling
@subsection Basic Signal Handling
@cindex @code{signal} function

The @code{signal} function provides a simple interface for establishing
an action for a particular signal.  The function and associated macros
are declared in the header file @file{signal.h}.
@pindex signal.h

@comment signal.h
@comment GNU
@deftp {Data Type} __sighandler_t
This is the type of signal handler functions.  Signal handlers take one
integer argument specifying the signal number, and have return type
@code{void}.  So, you should define handler functions like this:

@example
void @var{handler} (int @var{signum}) @{ @dots{} @}
@end example
@end deftp

@comment signal.h
@comment ANSI
@deftypefun __sighandler_t signal (int @var{signum}, __sighandler_t @var{action})
The @code{signal} function establishes @var{action} as the action for
the signal @var{signum}.

The first argument, @var{signum}, identifies the signal whose behavior you
want to control, and should be one of the signal names listed in
@ref{Signal Names}.  

The second argument, @var{action}, is a pointer to the function you want
to install as its handler.  This can be one of the following:

@itemize @bullet
@item 
@code{SIG_DFL}, to specify the default action for the particular signal.
The default actions are as described in @ref{Signal Names}.
@cindex default action for a signal

@item
@code{SIG_IGN}, to specify that the signal should be ignored.

It's not really a good idea to ignore most signals.  For one thing, you
cannot ignore the @code{SIGKILL} or @code{SIGSTOP} signals at all.  You
can have your program ignore program error signals like @code{SIGSEGV},
but doing so won't fix the bug in your program.  And, it is
user-unfriendly to ignore interactive signals like @code{SIGINT},
@code{SIGQUIT}, and @code{SIGTSTP}.
@cindex ignore action for a signal

As an alternative to ignoring a signal completely, it might make more
sense to block it temporarily.  @xref{Blocking Signals}.

@item 
A pointer to a function you write yourself.  For more information about
defining signal handler functions, @pxref{Defining a Signal Handler}.
@end itemize

If you set the action for a signal to @code{SIG_IGN}, or if you set it
to @code{SIG_DFL} and the default action is to ignore that signal, then
any pending signals of that type are discarded (even if they are still
blocked).

The @code{signal} function returns the action that was previously in
effect for the specified @var{signum}.  You can save this value and
restore it later by calling @code{signal} again.

If @code{signal} can't honor the request, it returns @code{SIG_ERR}
instead.  The following @code{errno} error conditions are defined for
this function:

@table @code
@item EINVAL
You specified an invalid @var{signum}; or you tried to ignore or provide
a handler for @code{SIGKILL} or @code{SIGSTOP}.
@end table
@end deftypefun

Here's a simple example of using the @code{signal} function.  The
following code causes @code{SIGUSR1} signals to be ignored, so that the
program can complete some critical operation that shouldn't be
interrupted by receipt of a signal of this type.  The variable
@code{old_action} stores whatever handler was in effect at the time.  At
the end of the operation, the program restores this handler.

@example
#include <signal.h>

void (*old_action)(int sig);

old_action = signal (SIGUSR1, SIG_IGN);  /* @r{Ignore the signal.} */
/* critical operations here */
signal (SIGUSR1, old_action);            /* @r{Allow the signal again.} */
@end example

@comment  Yes, I KNOW that signals arriving during the critical operations
@comment  will be lost.  But, I want only a very short example here, and do
@comment  not want to detract from the main point -- which is to show how to 
@comment  use the return value from signal to save and restore a signal
@comment  action -- with a long digression about ignoring signals being a 
@comment  bad idea and suggesting that people block the signal instead.

@comment signal.h
@comment SVID
@deftypefun __sighandler_t ssignal (int @var{signum}, __sighandler_t @var{action})
The @code{ssignal} function does the same thing as @code{signal}; it is
provided only for compatibility with SVID.
@end deftypefun


@comment signal.h
@comment ANSI
@deftypevr Macro __sighandler_t SIG_DFL
This macro can be used as the @var{action} argument to the @code{signal}
function.  It tells the system to use the default handling for the
signal.
@end deftypevr

@comment signal.h
@comment ANSI
@deftypevr Macro __sighandler_t SIG_IGN
This macro can be used as the @var{action} argument to the @code{signal}
function.  It tells the system to ignore the signal.
@end deftypevr

@comment signal.h
@comment ANSI
@deftypevr Macro __sighandler_t SIG_ERR
The value of this macro is used as the return value from @code{signal}
to indicate an error.
@end deftypevr

@ignore
@comment RMS says that ``we don't do this''.
Implementations might define additional macros for built-in signal
actions that are suitable as a @var{action} argument to @code{signal},
besides @code{SIG_IGN} and @code{SIG_DFL}.  Identifiers whose names
begin with @samp{SIG_} followed by an uppercase letter are reserved for
this purpose.
@end ignore


@node Advanced Signal Handling
@subsection Advanced Signal Handling
@cindex @code{sigaction} function

The @code{sigaction} function has the same basic effect as
@code{signal}: to specify how a signal should be handled by the process.
However, @code{sigaction} offers more control, at the expense of more
complexity.  In particular, @code{sigaction} allows you to specify
additional flags to control when the signal is generated and how the
handler is invoked.

The @code{sigaction} function is declared in @file{signal.h}.
@pindex signal.h

@comment signal.h
@comment POSIX.1
@deftp {struct Type} sigaction
Structures of type @code{sigaction} are used to specify signal actions
for the @code{sigaction} function.  It contains at least the following
members:

@table @code
@item __sighandler_t sa_handler
This is used in the same way as the @var{action} argument to the
@code{signal} function.  The value can be @code{SIG_DFL},
@code{SIG_IGN}, or a function pointer.  @xref{Basic Signal Handling}.

@item sigset_t sa_mask
This specifies a set of signals to be blocked while the handler runs.
Blocking is explained in @ref{Blocking Signals in a Handler}.

@item int sa_flags
This specifies various flags which can affect the behavior of 
the signal.  These are described in more detail in @ref{Sigaction Flags}.
@end table
@end deftp

@comment signal.h
@comment POSIX.1
@deftypefun int sigaction (int @var{signum}, const struct sigaction *@var{action}, struct sigaction *@var{old_action})
The @var{action} argument is used to set up a new action for the signal
@var{signum}, while the @var{old_action} argument is used to return
information about the action previously associated with this symbol.
(In other words, @var{old_action} has the same purpose as the
@code{signal} function's return value --- you can check to see what the
old action in effect for the signal was, and restore it later if you
want.)

Either @var{action} or @var{old_action} can be a null pointer.  If
@var{old_action} is a null pointer, this simply suppresses the return
of information about the old action.  If @var{action} is a null pointer,
the action associated with the signal @var{signum} is unchanged; this
allows you to inquire about how a signal is being handled without changing
that handling.

The return value from @code{sigaction} is zero if it succeeds, and
@code{-1} on failure.  The following @code{errno} error conditions are
defined for this function:

@table @code
@item EINVAL
The @var{signum} argument is not valid, or you are trying to
trap or ignore @code{SIGKILL} or @code{SIGSTOP}.
@end table
@end deftypefun

It's possible to use both the @code{signal} and @code{sigaction}
functions within a single program, but you have to be careful because
they can interact in slightly strange ways.

In particular, since the @code{sigaction} function specifies more
information than the @code{signal} function, the return value from
@code{signal} might not be usable to restore an action originally
established by @code{sigaction}.

You can rely on the old action structure returned by @code{sigaction}
being restorable by another call to @code{sigaction}, even if the action
was originally established by @code{signal}.  However, the function
returned as the @code{sa_handler} member of this structure might not be
the same as the @var{action} function specified as an argument to
@code{signal}, and might not be usable by itself as an argument to
@code{signal}.

So, you're better off using one or the other of the mechanisms
consistently within a single program.  

@strong{Portability Note:} The basic @code{signal} function is a feature
of ANSI C, while @code{sigaction} is part of the POSIX.1 standard.  If
you are concerned about portability to non-POSIX systems, then you
should use the @code{signal} function instead.

@node Sigaction Function Example
@subsection Sigaction Function Example

In @ref{Basic Signal Handling}, this short example was used to illustrate
the use of the @code{signal} function to cause @code{SIGUSR1} signals
to be ignored temporarily:

@example
#include <signal.h>

void (*old_action)(int sig);

old_action = signal (SIGUSR1, SIG_IGN);  /* @r{Ignore the signal.} */
/* critical operations here */
signal (SIGUSR1, old_action);            /* @r{Allow the signal again.} */
@end example

Now let's see how the same thing is done with the @code{sigaction}
function:

@example
struct sigaction new_action, old_action;
sigset_t block_mask;

/* @r{Set up the structure to specify the new action.} */
sigfillset (&block_mask);

new_action.sa_handler = SIG_IGN;
new_action.sa_mask = block_mask;
new_action.sa_flags = 0;

sigaction (SIGUSR1, &new_action, &old_action);
/* @r{Critical actions here.} */
sigaction (SIGUSR1, &old_action, NULL);
@end example

The activities on @code{block_mask} are described later; @pxref{Blocking
Signals}.  The program just loads the @code{new_action} structure with
the desired parameters and passes it in the @code{sigaction} call.

In the first call to @code{sigaction}, we want to save the existing
action for the signal, so it can be restored later.  So a pointer to the
@code{old_action} structure is passed as the third argument.  On the
second call, we don't need any information returned about the existing
action, so a null pointer is passed instead.

Here is another example.  It retrieves information about the current
action for @code{SIGINT} without changing that action.

@example
struct sigaction query_action;

if (sigaction (SIGINT, NULL, &query_action) < 0)
  /* @r{@code{sigaction} returns -1 in case of error} */ 
else if (query_action.sa_handler == SIG_DFL)
  /* @r{@code{SIGINT} is handled in the default, fatal manner} */
else if (query_action.sa_handler == SIG_IGN)
  /* @r{@code{SIGINT} is ignored} */
else
  /* @r{A programmer-defined signal handler is in effect} */
@end example


@node Sigaction Flags
@subsection Sigaction Flags
@cindex @code{sigaction} flags

This @code{sa_flags} member of the @code{sigaction} structure is a
catch-all for special features.  Most of the time, you can simply use
@code{0} for this field.

The value of @code{sa_flags} is interpreted as a bit mask.  Thus, you
can choose the flags you want to have set for some reason, OR those
flags together, and assign them to the @code{sa_flags} member of your
@code{sigaction} structure.

These macros are defined in the header file @file{signal.h}.
@pindex signal.h

@comment signal.h
@comment POSIX.1
@deftypevr Macro int SA_NOCLDSTOP
The value of this macro is an integer constant that can be used as a
flag for @code{sa_flags} when setting up an action for the
@code{SIGCHLD} signal.  When the flag is set, the system delivers the
signal for a terminated child process but not for one that is stopped.
By default, @code{SIGCHLD} is delivered for both terminated children and
stopped children.
@end deftypevr

@comment signal.h
@comment BSD
@deftypevr Macro int SA_ONSTACK
If this flag is set, the system uses the signal stack when delivering
the signal.  @xref{BSD Signal Handling}.
@end deftypevr

@comment signal.h
@comment BSD
@deftypevr Macro int SA_RESTART
If this flag is set, system calls interrupted by a signal return with
an @code{EINTR} error instead of restarting.
@end deftypevr



@node Initial Signal Actions
@subsection Initial Signal Actions
@cindex initial signal actions

When a new process is created (@pxref{Creating a Process}), it inherits
handling of signals from its parent process.  However, when you load a
new process image using the @code{exec} function (@pxref{Executing a
File}), any signals that you've defined your own handlers for revert to
their @code{SIG_DFL} handling.  (If you think about it a little, this
makes sense; the handler functions from the old program are specific to
that program, and aren't even present in the address space of the new
program image.)  Of course, the new program can establish its own
handlers.

When a program is run by a shell, the shell normally sets the initial
actions for the child process to @code{SIG_DFL} or @code{SIG_IGN}, as
appropriate.  It's a good idea to check to make sure that the shell has
not set up an initial action of @code{SIG_IGN} before you establish your
own signal handlers.

@strong{Incomplete:}  RMS suggests putting an example here.


@node Defining a Signal Handler
@section Defining a Signal Handler

This section describes how to write a signal handler function that can
be established with the @code{signal} or @code{sigaction} functions.

A signal handler is just a function that you compile together with the
rest of the program.  Instead of directly invoking the function, you use
@code{signal} or @code{sigaction} to tell the operating system to call
it when a signal arrives.  This is known as @dfn{enabling} the handler.
@cindex enabling a signal handler
@cindex signal handler function

You need to take special care in writing handler functions because they
can be called asynchronously.  That is, a handler might be called at any
point in the program, unpredictably.  If two signals arrive during a
very short interval, the operating system might even restart the handler
while it is handling the first signal!  This section describes what your
handler should do, and what you should avoid.

@menu
* Signal Handler Example::		An example.
* Handling Multiple Signals::		What happens if another signal arrives
				 	 when your handler function is running.
* Restrictions on Handler Functions::   What handlers can and can't do.
@end menu

@node Signal Handler Example
@subsection Signal Handler Example

There are two basic strategies you can use in signal handler functions:

@itemize @bullet
@item
You can have the handler function note that the signal arrived by
tweaking some global data structures, and then return normally.

@item
You can have the handler function terminate the program or transfer
control to a point where it can recover from the situation that caused
the signal.
@end itemize

Handlers which return normally are usually only useful for signals such
as @code{SIGALRM} and other interprocess communication signals.  This
isn't a reliable technique for handling program error signals like
@code{SIGFPE} and @code{SIGSEGV}, because the behavior of the program
when the handler function returns is not defined after a program error.

Typically, a handler that returns normally tweaks some global data
structures that are examined synchronously from time to time during
normal execution of the program.

Here is a simple example of such a program.  It executes the body of
the loop until it has noticed that a @code{SIGALRM} signal has arrived.
This technique is useful because it allows the iteration in progress
when the signal arrives to complete before the loop exits.

@example
#include <signal.h>
#include <stdlib.h>

/* @r{This flag controls termination of the main loop.} */

volatile sig_atomic_t keep_going = 1;


/* @r{The signal handler just clears the flag and re-enables itself.}
 * @r{Actually, for this program re-enabling the handler isn't necessary,}
 * @r{since only one alarm signal has to be caught in order to cause it}
 * @r{to terminate.}
 */

void catch_alarm (int sig)
@{
  keep_going = 0;
  signal (sig, catch_alarm);
@}

main (void)
@{
  
  /* @r{Establish a handler for @code{SIGALRM} signals.} */
  signal (SIGALRM, catch_alarm);

  /* @r{Set an alarm to go off in a little while.}  */
  alarm (2);

  /* @r{Check the flag once in a while to see when to quit.} */
  while (keep_going)
    do_stuff ();
  exit (EXIT_SUCCESS);
@}      
@end example

Handler functions that cause a nonlocal transfer of control or program
termination are typically used to cause orderly cleanup or recovery from
program error signals and interactive interrupts.

Process termination within a handler is typically performed by resending
the signal.  For example, GNU Emacs sets up a handler for most fatal
signals that looks something like:

@example
volatile sig_atomic_t fatal_error_in_progress = 0;

void fatal_error_signal (int sig)
@{

  /* @r{Immediately set the action for this signal back to the default.}
   * @r{This will prevent the handler from being invoked recursively if}
   * @r{another fatal signal happens while the handler is executing.}
   */
  signal (sig, SIG_DFL);

  /* @r{Since this handler is established for more than one kind of signal, }
   * @r{it might still get invoked recursively by delivery of some other kind}
   * @r{of signal.  Use a static variable to keep track of that.}
   */

  if (fatal_error_in_progress)
    raise (sig);
  fatal_error_in_progress = 1;

  /* @r{Now do the clean up actions:}
   * @r{- reset terminal modes}
   * @r{- kill child processes}
   * @r{- auto save buffers being edited}
   * @r{- remove lock files}
   */
  @dots{}

  /* @r{Now resend the signal.  Since we set the handling for it back to}
   * @r{its default, this will cause the program to terminate.  We could}
   * @r{just call @code{exit} or @code{abort} here, but resending the signal}
   * @r{will set the return status from the process correctly.}
   */
  raise (sig);
@}
@end example

You can do a nonlocal transfer of control out of a signal handler using
the @code{setjmp} and @code{longjmp} facilities (@pxref{Non-Local
Exits}).  However, if you do this, you must take care in setting up the
return point.  For example, if you want to make sure that global data
structures are in a consistent state after doing a @code{longjmp} out of
a signal handler, you must either re-initialize them or else ensure that
your signal handler won't be invoked while they are in an inconsistent
state by blocking signals around the critical sections of your program.
@xref{Blocking Signals}.
@cindex non-local exit, from signal handler

@strong{Incomplete:}  RMS suggests putting another example here.


@node Handling Multiple Signals
@subsection Handling Multiple Signals
@cindex race conditions, relating to signals
@cindex handling multiple signals

What happens if another signal arrives when your signal handler function
is running?

In the GNU system, when a handler for a particular signal is invoked,
that signal is normally blocked until the handler returns.  That means
that if two signals of the same kind arrive close together, the second
one will be held until the first has been handled.  (The handler can
explicitly unblock the signal using @code{sigprocmask}, if you want to
allow more signals of this type to arrive; @pxref{Process Signal Mask})

However, your handler can still be interrupted by delivery of another
kind of signal.  To avoid this, you can use the @code{sa_mask} member of
the action structure passed to @code{sigaction} to explicitly specify
which signals should be blocked while the signal handler runs.  These
signals are in addition to the signal for which the handler was invoked,
and any other signals that are normally blocked by the process.
@xref{Blocking Signals in a Handler}.

If more than one signal of the same type is delivered to your process
before your signal handler has a chance to be invoked at all, your
handler may only be invoked once, as if only a single signal had
arrived.  This situation can arise when the signal is blocked, or in a
multiprocessing environment where the system is busy running some other
processes while the signals are delivered.  This means, for example,
that you cannot reliably use a signal handler to count signals.

@strong{Incomplete:} RMS suggests putting an example here showing a
handler for @code{SIGCHLD}; the handler needs to have a loop since there
may be more than one child process with status information available.

@strong{Portability Note:} In System V Unix, handlers established with
@code{signal} behave somewhat differently.  Before calling the handler
function, the action for the signal is set back to @code{SIG_DFL}.  This
means that the handler must re-enable itself before exiting and do any
signal blocking explicitly.  It also means that there is still a
possibility that another signal could arrive in the moment before you've
had a chance to alter the handling of the signal.  The ANSI C standard
permits this behavior, but you do not need to worry about this if you
are using only the GNU system.


@node Restrictions on Handler Functions
@subsection Restrictions on Handler Functions
@cindex restrictions on signal handler functions

Handler functions usually don't do very much.  The recommended behavior
is to just have the handler set an external variable that the program
checks regularly, and leave all serious work to the program.  This is
because the handler can be called at asynchronously, at unpredictable
times --- perhaps in the middle of a system call, or even between the
beginning and the end of a floating-point operation that requires
multiple instructions.  The data structures being manipulated might
therefore be in an inconsistent state when the handler function is
invoked.

This means you have to be very careful about what you do in a signal
handler.

@itemize @bullet
@item
Do not call any functions, including those from the standard libraries,
unless you are sure they are @dfn{reentrant} with respect to signals.
@cindex reentrant functions

The most usual reason why a function fails to be reentrant is the use of
static or global data structures.  As an example of what can go wrong,
suppose that the sample program prints a message through a @code{printf}
call in the signal handler.  Suppose also that @code{printf} and
@code{fprintf} share some common internal data structures, and that the
main program was in the middle of an @code{fprintf} call when the signal
was delivered.  Both the signal handler's message and the program's data
could end up getting corrupted.

@strong{Incomplete:} There should be a table here listing functions that
are guaranteed to be reentrant, and/or something in each individual
function description to indicate whether it's reentrant.

@item
If your handler calls any library functions that can modify the value of
@code{errno}, it should save and restore the original value of
@code{errno} before returning normally.  This prevents errors that occur
within the signal handler from being confused with errors from system
calls at the point the program is interrupted to run the handler.

@item
If your handler needs to access any global variables from your program,
those variables must be declared @code{volatile}.  This tells the
compiler that the value of the variable might change asynchronously, and
keeps it from making some kinds of optimizations that would be
invalidated by such modifications.
@cindex @code{volatile} declarations

@item
The only data type that can be accessed as an atomic operation is the
@code{sig_atomic_t} type.  Accesses to other kinds of objects might be
interruptible by a signal; the data might be in an inconsistent state
when the handler function is called.  There are similar problems if your
handler uses a set of variables which are supposed to be updated
together.

The way you can get around this problem is by blocking all signals that
have handlers that might access the variables around all the parts of
the program that manipulate the variables, including in the handlers
themselves.  @xref{Blocking Signals}, for information on how to do this.
@end itemize

@comment signal.h
@comment ANSI
@deftp {Data Type} sig_atomic_t
This is an integer data type.  It identifies a type of object that can
be accessed as an atomic entity, even in the presence of asynchronous
interrupts.
@end deftp

@strong{Incomplete:} RMS suggests putting an example here to show what
this implies.


@node Generating Signals
@section Generating Signals
@cindex sending signals
@cindex raising signals
@cindex signals, generating

Besides signals that are generated as a result of a hardware trap or
interrupt, your program can explicitly send signals to itself or to
another process.

@menu
* Raising a Signal::		Send yourself any desired signal.
* Signaling Another Process::	Send a signal to another process.
@end menu


@node Raising a Signal
@subsection Raising a Signal

A process can send itself a signal with the @code{raise} function.  This
function is declared in @file{signal.h}.
@pindex signal.h

@comment signal.h
@comment ANSI
@deftypefun int raise (int @var{signum})
The @code{raise} function sends the signal @var{signum} to the calling
process.  It returns zero if successful and a nonzero value if it fails.
About the only reason for failure would be if the value of @var{signum}
is invalid.
@end deftypefun

@comment signal.h
@comment SVID
@deftypefun int gsignal (int @var{signum})
The @code{gsignal} function does the same thing as @code{raise}; it is
provided only for compatibility with SVID.
@end deftypefun

One convenient use for @code{raise} is to reproduce the default behavior
of a signal that you have trapped.  For instance, suppose a user of your
program types the SUSP character (usually @kbd{C-z}; @pxref{Special
Characters}) to send it an interactive stop stop signal
(@code{SIGTSTP}), and you want to clean up some internal data buffers
before stopping.  You might set this up like this:

@comment RMS suggested getting rid of the handler for SIGCONT in this function.
@comment But that would require that the handler for SIGTSTP unblock the
@comment signal before doing the call to raise.  We haven't covered that
@comment topic yet, and I don't want to distract from the main point of
@comment the example with a digression to explain what is going on.  As
@comment the example is written, the signal that is raise'd will be delivered
@comment as soon as the SIGTSTP handler returns, which is fine.

@example
#include <signal.h>

/* @r{When a stop signal arrives, set the action back to the default}
 * @r{and then resend the signal after doing cleanup actions.}
 */

void tstp_handler (int sig)
@{
  signal (SIGTSTP, SIG_DFL);
  /* @r{Do cleanup actions here.} */
  @dots{}
  raise (SIGTSTP);
@}

/* @r{When the process is continued again, restore the signal handler.}
 */

void cont_handler (int sig)
@{
  signal (SIGCONT, cont_handler);
  signal (SIGTSTP, tstp_handler);
@}

/* @r{Enable both handlers during program initialization.}
 */

main (void)
@{
  signal (SIGCONT, cont_handler);
  signal (SIGTSTP, tstp_handler);
  @dots{}
@}
@end example


@node Signaling Another Process
@subsection Signaling Another Process

@cindex killing a process
The @code{kill} function can be used to send a signal to another process.
In spite of its name, it can be used for a lot of things other than
causing a process to terminate.  Some examples of situations where you
might want to send signals between processes are:

@itemize @bullet
@item
A parent process starts a child to perform a task --- perhaps having the
child running an infinite loop --- and then terminates the child when
the task is no longer needed.

@item
A process executes as part of a group, and needs to terminate or notify
the other processes in the group when an error or other event occurs.

@item
Two processes need to synchronize while working together.
@end itemize

This section assumes that you know a little bit about how processes
work.  For more information on this subject, @pxref{Processes}.

The @code{kill} function is declared in @file{signal.h}.
@pindex signal.h

@comment signal.h
@comment POSIX.1
@deftypefun int kill (pid_t @var{pid}, int @var{signum})
The @code{kill} function sends the signal @var{signum} to the process
or process group specified by @var{pid}.  Besides the signals listed in
@ref{Signal Names}, @var{signum} can also have a value of zero to
check the validity of the @var{pid}.

The @var{pid} specifies the process or process group to receive the
signal:

@table @code
@item @var{pid} > 0
The process whose identifier is @var{pid}.

@item @var{pid} == 0
All processes in the same process group as the sender.  The sender
itself does not receive the signal.

@item @var{pid} < -1
The process group whose identifier is the absolute value of
@var{pid}.

@item @var{pid} == -1
If the process is privileged, send the signal to all processes except
for some special system processes.  Otherwise, send the signal to all
processes with the same effective user ID.
@end table

If @code{kill} is used by a process to send a signal to itself, and the
signal is not blocked, then @code{kill} delivers at least one signal
(which might be some other pending unblocked signal instead of the
signal @var{signum}) to that process before it returns.

The return value from @code{kill} is zero if the signal can be sent
successfully.  Otherwise, no signal is sent, and a value of @code{-1} is
returned.

The following @code{errno} error conditions are defined for this function:

@table @code
@item EINVAL
The @var{signum} argument is an invalid or unsupported number.

@item EPERM
You do not have the privilege to send a signal to the process or any of
the processes in the process group named by @var{pid}.

@item ESCRH
The @var{pid} argument does not refer to an existing process or group.
@end table
@end deftypefun

@comment signal.h
@comment BSD
@deftypefun int killpg (int @var{pgid}, int @var{signum})
This is similar to @code{kill}, but sends signal @var{signum} to the
process group @var{pgid}.  This function is provided for compatibility
with BSD; using @code{kill} to do this is more portable.
@end deftypefun

There are restrictions that prevent you from using @code{kill} to send
signals to any random process.  In typical use, @code{kill} is used to
pass signals between parent, child, and sibling processes, and in these
situations you don't have to worry too much about getting the
appropriate permissions to send signals.  The restrictions on who can
send signals to process are intended to prevent antisocial behavior like
arbitrarily killing off processes belonging to another user.

Whether a process has permission to send a signal to another process
is determined by the user IDs of the two processes.  This concept is
discussed in detail in @ref{User/Group IDs of a Process}.

Generally, for a process to be able to send a signal to another process,
either the sending process must belong to a privileged user (like
@samp{root}), or the real or effective user ID of the sending process
must match the real or effective user ID of the receiving process.  If
the receiving process has changed its effective user ID from the
set-user-ID mode bit on its process image file, then the owner of the
process image file is used in place of its current effective user ID.
In some implementations, a parent process might be able to send signals
to a child process even if the user ID's don't match, and other
implementations might enforce other restrictions.

The @code{SIGCONT} signal is a special case.  It can be sent if the
sender is part of the same session as the receiver, regardless of
user IDs.

As a simple example of @code{kill}, the call:

@example
kill (getpid (), @var{sig})
@end example

@noindent
has the same effect as:

@example
raise (@var{sig})
@end example

@cindex interprocess communication, with signals
Here is a longer example showing how signals can be used for
interprocess communication.  This is what the @code{SIGUSR1} and
@code{SIGUSR2} signals are provided for.  Since these signals are fatal
by default, the process that is supposed to receive them must trap them
through @code{signal} or @code{sigaction}.

In this example, a parent process forks a child process and then waits
for the child to complete its initialization.  The child process tells
the parent when it is ready by sending it a @code{SIGUSR1} signal, using
the @code{kill} function.

@example
#include <signal.h>
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>

/* @r{When a @code{SIGUSR1} signal arrives, set this variable.}
 */

volatile sig_atomic_t usr_interrupt = 0;

void synch_signal (int sig)
@{
  usr_interrupt = 1;
@}


/* @r{The child process executes this function.}
 */

void child_function (void)
@{
  /* @r{Perform initialization.} */
  printf ("I'm here!!!  My pid is %d.\n", (int)getpid());

  /* @r{Let parent know you're done.} */
  kill (getppid (), SIGUSR1);  

  /* @r{Continue with execution.} */
  printf ("Bye, now....\n");
  exit (0);
@}


void main (void)
@{
  struct sigaction usr_action;
  sigset_t block_mask;
  pid_t child_id;

  /* @r{Establish the signal handler.} */
  sigfillset (&block_mask);
  usr_action.sa_handler = synch_signal;
  usr_action.sa_mask = block_mask;
  usr_action.sa_flags = 0;
  sigaction (SIGUSR1, &usr_action, NULL);

  /* @r{Create the child process.} */
  if ((child_id = fork ()) == 0)
    child_function ();  /* @r{Does not return} */

  /* @r{Busy wait for child to send a signal.} */
  while (!usr_interrupt) @{@}

  /* @r{Now continue execution.} */
  printf ("That's all, folks!\n");
  exit (0);
@}
@end example

Using a busy wait, as this program does, is not really a good idea.
There is an example in @ref{Waiting for a Signal} that shows you how
you can make a program block until a signal arrives.

@node Blocking Signals
@section Blocking Signals
@cindex blocking signals

Blocking a signal means telling the operating system to hold it and
deliver it later.  Generally, a program does not block signals
indefinitely --- it might as well ignore them by setting their actions
to @code{SIG_IGN}.  But it is useful to block signals briefly, to
prevent them from interrupting sensitive operations.  For instance:

@itemize @bullet
@item
You can use the @code{sigprocmask} function to block signals while you
modify global variables that are also modified by the handlers for these 
signals.

@item
You can set @code{sa_mask} in your @code{sigaction} call so that the
signal handler can run without being interrupted itself by signals.
@end itemize

@menu
* Signal Sets::				How to specify which signals to block.
* Process Signal Mask::			Blocking delivery of signals to your
					 process during normal execution.
* Blocking Signals in a Handler::	Blocking additional signals while a
					 handler is being run.
* Checking for Pending Signals::	How to tell if there are signals
					 waiting to be delivered.
@end menu

@node Signal Sets
@subsection Signal Sets

All of the signal blocking functions use a data structure called a
@dfn{signal set} to specify what signals are affected.  Thus, every
activity involves two stages: creating the signal set, and then passing
it as an argument to a library function.
@cindex signal set

These facilities are declared in the header file @file{signal.h}.
@pindex signal.h

@comment signal.h
@comment POSIX.1
@deftp {Data Type} sigset_t
The @code{sigset_t} data type is used to represent a signal set.
Internally, it may be implemented as either an integer or structure
type.  A bitmask representation is typical, but you're better off using
the various functions described in this section to initialize, change,
and retrieve information from @code{sigset_t} objects, than trying to
manipulate them directly.
@end deftp

There are two ways to initialize a signal set.  You can initially
specify it to be empty with @code{sigemptyset} and then add specified
signals individually.  Or you can specify it to be full with
@code{sigfillset} and then delete specified signals individually.  You
must always initialize the signal set with one of these two functions
before using it in any other way.  You can't just set all the signals
explicitly because the @code{sigset_t} object might include some other
information (like a version field) that needs to be initialized as well.

@comment signal.h
@comment POSIX.1
@deftypefun int sigemptyset (sigset_t *@var{set})
This function is used to initialize the signal set @var{set} to 
exclude all of the defined signals.  The return value is @code{0}.
@end deftypefun

@comment signal.h
@comment POSIX.1
@deftypefun int sigfillset (sigset_t *@var{set})
This function is used to initialize the signal set @var{set} to include
all of the defined signals.  Again, the return value is @code{0}.
@end deftypefun

@comment signal.h
@comment POSIX.1
@deftypefun int sigaddset (sigset_t *@var{set}, int @var{signum})
This function adds the signal @var{signum} to the signal set @var{set}.
All @code{sigaddset} does is modify @var{set}; it does not block or
unblock any signals.

The return value is @code{0} on success and @code{-1} on failure.
The following @code{errno} error condition is defined for this function:

@table @code
@item EINVAL
The @var{signum} argument doesn't specify a valid signal.
@end table
@end deftypefun

@comment signal.h
@comment POSIX.1
@deftypefun int sigdelset (sigset_t *@var{set}, int @var{signum})
This function removes the signal @var{signum} from the signal set
@var{set}.  All @code{sigdelset} does is modify @var{set}; it does not
block or unblock any signals.  The return value and error conditions are
the same as for @code{sigaddset}.
@end deftypefun

Finally, there is this predicate function:

@comment signal.h
@comment POSIX.1
@deftypefun int sigismember (const sigset_t *@var{set}, int @var{signum})
The @code{sigismember} function tests whether the signal @var{signum} is
a member of the signal set @var{set}.  It returns @code{1} if the signal
is in the set, @code{0} if not, and @code{-1} if there is an error.

The following @code{errno} error condition is defined for this function:

@table @code
@item EINVAL
The @var{signum} argument doesn't specify a valid signal.
@end table
@end deftypefun


@node Process Signal Mask
@subsection Process Signal Mask

The collection of signals that are currently blocked is called the
@dfn{signal mask}.  Each process has its own signal mask.  When you
create a new process (@pxref{Creating New Processes}), it inherits
its parent's mask.
@cindex signal mask
@cindex process signal mask

The prototype for the @code{sigprocmask} function is in @file{signal.h}.
@pindex signal.h

@comment signal.h
@comment POSIX.1
@deftypefun int sigprocmask (int @var{how}, const sigset_t *@var{set}, sigset_t *@var{oldset})
The @code{sigprocmask} function is used to examine or change the calling
process's signal mask.  The @var{how} argument determines how the signal
mask is changed, and must be one of the following values:

@table @code
@item SIG_BLOCK
Add the signals in @var{set} to the existing mask.  In other words, the
new mask is the union of the existing mask and @var{set}.

@item SIG_UNBLOCK
Remove the signals in @var{set} from the existing mask.

@item SIG_SETMASK
Use @var{set} for the mask; ignore current contents of the mask.
@end table

The last argument, @var{oldset}, is used to return information about the
old process signal mask.  If you just want to change the mask without
looking at it, pass a null pointer as the @var{oldset} argument.
Similarly, if you want to know what's in the mask without changing it,
pass a null pointer for @var{set} (in this case the @var{how} argument
is not significant).  The @var{oldset} argument is particularly useful
if you want to remember the original set of blocked signals in order to
restore it later.  (Since the signal mask is inherited over @code{fork}
and @code{exec} calls, you can't predict what its contents are when your
program starts running.)

If invoking @code{sigprocmask} causes any pending signals to be
unblocked, at least one of those signals is delivered to the process
before @code{sigprocmask} returns.  The order in which pending signals
are delivered is not specified, but you can set up a hierarchy by making
multiple @code{sigprockmask} calls to unblock various signals one at
a time.

The @code{sigprocmask} function returns @code{0} if successful, and @code{-1}
to indicate an error.  The following @code{errno} error conditions are
defined for this function:

@table @code
@item EINVAL
The @var{how} argument is invalid.
@end table

You can't block the @code{SIGKILL} and @code{SIGSTOP} signals, but
if the signal set includes these, @code{sigprocmask} just ignores
them instead of returning an error status.

Remember, too, that blocking program error signals such as @code{SIGFPE}
usually doesn't do anything useful for signals generated by an actual
program error (as opposed to signals sent with @code{raise} or
@code{kill}).  This is because your program may be too broken to be
able to continue executing to a point where the signal is unblocked
again.
@end deftypefun

@comment signal.h
@comment POSIX.1
@deftypevr Macro int SIG_BLOCK
The value of this macro is an integer suitable for use as the @var{how}
argument to @code{sigprocmask}, to specify that the process signal mask
should be set to the union of the specified set with the current process
signal mask.
@end deftypevr

@comment signal.h
@comment POSIX.1
@deftypevr Macro int SIG_UNBLOCK
The value of this macro is an integer suitable for use as the @var{how}
argument to @code{sigprocmask}, to specify that the signals in the
specified set should be removed from the current process signal mask.
@end deftypevr

@comment signal.h
@comment POSIX.1
@deftypevr Macro int SIG_SETMASK
The value of this macro is an integer suitable for use as the @var{how}
argument to @code{sigprocmask}, to specify that the process signal mask
should be set to the specified signal set.
@end deftypevr

Temporary blocking of signals with @code{sigprocmask} is useful primarily
when you want to lock out interrupts during critical parts
of your code.  One example of this kind of situation is where you
are accessing data that is shared with a signal handler.

As described in @ref{Defining a Signal Handler}, the most reliable way
to have your program deal with a signal is to create an external,
@code{volatile} variable and make your signal handler change its value.
The problem arises when your program needs to access or modify this
variable.  Even if you check the variable to see whether a signal has
arrived immediately before you set it, another signal might still arrive
in the meantime, and you will never know it was there.  You can avoid
this problem by blocking the signal during the time you are performing
the check and modification.

A related situation is where you have several variables or variables of
types other than @code{sig_atomic_t} that are being manipulated by one
or more signal handlers.  In this kind of situation, you want to be sure
that operations on this data are performed as a complete unit.  You can
implement a locking protocol for the data by temporarily blocking the
signals that might otherwise cause the data to be modified.

Now for a simple example.  Suppose you establish a handler for
@code{SIGALRM} signals that sets a flag whenever a signal arrives, and
your main program checks this flag from time to time and then resets it.
You can prevent additional @code{SIGALRM} signals from arriving in the
meantime by wrapping the critical part of the code with calls to
@code{sigprocmask}, like this:

@example
/* @r{This variable is set by the SIGALRM signal handler.} */
volatile sig_atomic_t flag = 0;

void main (void)
@{
  sigset_t block_alarm;

  @dots{}

  /* @r{Initialize the signal mask.} */
  sigemptyset (&block_alarm);
  sigaddset (&block_alarm, SIGALRM);


  while (1) @{

    /* @r{Check if a signal has arrived; if so, reset the flag.} */
    sigprocmask (SIG_BLOCK, &block_alarm, NULL);
    if (flag) @{
      @dots{}
      flag = 0;
      @}
    sigprocmask (SIG_UNBLOCK, &block_alarm, NULL);

    @dots{}
  @}
@}
@end example

@node Blocking Signals in a Handler
@subsection Blocking Signals in a Handler
@cindex blocking signals, in a handler

When a signal handler is invoked, you usually want to let it run to
completion before another signal arrives.  From the moment the
handler starts until the moment it finishes, you must block signals
that might confuse it or corrupt its data.

When a handler function is invoked on a signal, that signal is
automatically blocked (in addition to any other signals that are already
in the process's signal mask) during the time the handler is running.
If you set up a handler for @code{SIGTSTP}, for instance, then the
arrival of that signal forces further @code{SIGTSTP} signals to wait
during the execution of the handler.

You can temporarily block additional signals when the handler is running
by using the @code{sa_mask} member of the @code{sigaction} structure.

Here is an example:

@example
#include <signal.h>
#include <stddef.h>

void catch_stop ();

/* @r{Block all terminal-generated signals while handler runs.} */
void install_handler (void)
@{
  struct sigaction setup_action;
  sigset_t block_mask;

  sigemptyset (&block_mask);
  sigaddset (&block_mask, SIGINT);
  sigaddset (&block_mask, SIGQUIT);
  sigaddset (&block_mask, SIGTSTP);
  setup_action.sa_handler = catch_stop;
  setup_action.sa_mask = block_mask;
  setup_action.sa_flags = 0;
  sigaction (SIGTSTP, &setup_action, NULL);
@}
@end example

You cannot remove signals from the process's current mask using this
mechanism.  However, you can make calls to @code{sigprocmask} within
your handler to put any mask you want in place.  In any case, when the
handler returns, the system restores the mask that was in place before
the handler was entered.


@node Checking for Pending Signals
@subsection Checking for Pending Signals
@cindex pending signals, checking for
@cindex blocked signals, checking for
@cindex checking for pending signals

You can find out which signals are pending at any time by calling
@code{sigpending}.  This function is declared in @file{signal.h}.
@pindex signal.h

@comment signal.h
@comment POSIX.1
@deftypefun int sigpending (sigset_t *@var{set})
The @code{sigpending} function stores information about pending signals
in @var{set}.  If there is a pending signal that is blocked from
delivery, then that signal is a member of the returned set.  (You can
test whether a particular signal is a member of this set using
@code{sigismember}; @pxref{Signal Sets}.)

The return value is @code{0} if successful, and @code{-1} on failure.
@end deftypefun


Here is an example.

@example
#include <signal.h>
#include <stddef.h>

sigset_t base_mask, waiting_mask;

sigemptyset (&base_mask);
sigaddset (&base_mask, SIGINT);
sigaddset (&base_mask, SIGTSTP);

/* @r{Block user interrupts while doing other processing.} */
sigprocmask (SIG_SETMASK, &base_mask, NULL); 
@dots{}

/* @r{After a while, check to see whether any signals are pending.} */
sigpending (&waiting_mask);
if (sigismember (&waiting_mask, SIGINT)) @{
  /* @r{User has tried to kill the process.} */
  @}
else if (sigismember (&waiting_mask, SIGTSTP)) @{
  /* @r{User has tried to stop the process.} */
  @}
@end example

Remember that if there is a particular signal pending for your process,
additional signals of that same type that arrive in the meantime might
be discarded.  For example, if a @code{SIGINT} signal is pending when
another @code{SIGINT} signal arrives, your program will probably only
see one of them when you unblock this signal.

@node Waiting for a Signal
@section Waiting for a Signal
@cindex waiting for a signal
@cindex @code{sleep} function
@cindex @code{pause} function

If your program is driven by external events, or uses signals for
synchronization, there are times you might want to suspend execution
until a signal arrives.  If you block the process in this way, it won't
use any CPU time while it is waiting.

The @code{pause} and @code{sleep} functions are declared in the header
file @file{unistd.h}, while @code{sigsuspend} is declared in
@file{signal.h}.
@pindex signal.h
@pindex unistd.h

@comment unistd.h
@comment POSIX.1
@deftypefun int pause (void)
The @code{pause} function suspends program execution until a signal
arrives whose action is either to execute a handler function, or to
terminate the process.

If the signal causes a handler function to be executed, then @code{pause}
returns.  This is considered an unsuccessful return (since ``successful''
behavior would be to suspend the program forever), so the return value
is @code{-1}.

The following @code{errno} error conditions are defined for this function:

@table @code
@item EINTR
The function was interrupted by delivery of a signal.
@end table

If the signal causes program termination, @code{pause} doesn't return
(obviously).
@end deftypefun

If you only want your program to delay execution for a limited period of
time (as opposed to indefinitely), you can use the @code{sleep} function
instead of @code{pause}.  A common situation is using @code{sleep} in a
loop, to make the process ``wake up'' periodically to perform some
actions.

@comment unistd.h
@comment POSIX.1
@deftypefun {unsigned int} sleep (unsigned int @var{seconds})
The @code{sleep} function is like @code{pause}, except that execution
is suspended only for the amount of time specified by the @var{seconds}
argument instead of indefinitely.  

The @code{sleep} function might be implemented using an alarm;
@pxref{Setting an Alarm}.  If another @code{SIGALRM} signal arrives
during the time the process is sleeping, strange things can happen.
Even if @code{SIGALRM} signals are being ignored or blocked when
@code{sleep} is called, @code{sleep} might return prematurely on
delivery of a @code{SIGALRM} signal.  If you have established a handler
for @code{SIGALRM} signals and a @code{SIGALRM} signal is delivered
while the process is sleeping, the action taken might be just to cause
@code{sleep} to return instead of invoking your handler.  And, if
@code{sleep} is interrupted by delivery of a signal whose handler messes
with @code{SIGALRM} signals, things can really get confused.  In short,
avoid messing with @code{SIGALRM} directly if you use @code{sleep}.

If @code{sleep} function returns because the requested time has
elapsed, it returns a value of zero.  If it returns because of delivery
of a signal, its return value is the remaining time in the sleep period.
@end deftypefun

Watch out for checking to see whether a signal has been reported and
then calling @code{pause} to wait for a signal if it hasn't arrived yet.
The signal might actually arrive in between the two operations and your
program will never wake up.  A better solution is to use
@code{sigprocmask} to block signals while you check to see if a signal
has arrived yet, and then use @code{sigsuspend} to both restore the
original signal mask and suspend execution in one uninterruptable
operation.

@comment signal.h
@comment POSIX.1
@deftypefun int sigsuspend (const sigset_t *@var{set})
This function replaces the process's signal mask with @var{set} and then
suspends the process until a signal is delivered whose action is either
to terminate the process or invoke a signal handling function.  In other
words, the program is effectively suspended until one of the signals that
is not a member of @var{set} arrives.

If the process is woken up by deliver of a signal that invokes a handler
function, and the handler function returns, then @code{sigsuspend} also
returns.  It sets the process's signal mask back to what it was when
@code{sigsuspend} was called.  

The return value and error conditions are the same as for @code{pause}.
@end deftypefun

As an example of how these functions might be used, let's reconsider the
program presented in @ref{Signaling Another Process}.  As originally
written, this program does a busy wait for a @code{SIGUSR1} signal to
arrive by sitting in a tight loop, checking a variable that is set by
the signal handler, like this:

@example
while (!usr_interrupt) @{@}
@end example

Doing a busy wait is not really a good idea, since it wastes system 
resources that could better be used by another process.  Having the
process block until the signal arrives would be much better.

Naively, one might expect to rewrite this loop instead as simply:

@example
while (!usr_interrupt)
  pause ();
@end example

@noindent
But this has a bug: the signal could arrive after the variable
@code{usr_interrupt} is checked, but before the call to @code{pause}.
In this case, the process would never wake up again.

To avoid this problem, you can use a combination of @code{sigprocmask}
and @code{sigsuspend}, like this:

@example
sigset_t mask, oldmask;

@dots{}

/* @r{Set up the mask of signals to temporarily block.} */ 
sigemptyset (&mask); 
sigaddset (&mask, SIGUSR1);

@dots{}

/* @r{Wait for a signal to arrive.} */
sigprocmask (SIG_BLOCK, &mask, &oldmask);
while (!usr_interrupt)
  sigsuspend (&oldmask);
sigprocmask (SIG_UNBLOCK, &mask, NULL);
@end example

This last piece of code is a little tricky.  The key point to remember
here is that when @code{sigsuspend} returns, it resets the process's
signal mask to be the original value from before the call to
@code{sigsuspend} --- in this case, the @code{SIGUSR1} signal is once
again blocked.  The second call to @code{sigprocmask} is
necessary to explicitly unblock this signal.

One other point: you may be wondering why the @code{while} loop is
necessary at all, since the program is apparently only waiting for one
@code{SIGUSR1} signal.  The answer is that the mask passed to
@code{sigsuspend} permits the process to be woken up by the delivery of
other kinds of signals, as well --- for example, job control signals.
If the process is woken up by a signal that doesn't set
@code{usr_interrupt}, it just suspends itself again until the ``right''
kind of signal eventually arrives.


@node BSD Signal Handling
@section BSD Signal Handling

This section describes signal handling functions included in the GNU C
library for backward compability with BSD Unix.  In new programs, you
should avoid these functions and use the POSIX-standard functions
instead, because they are more general in some ways.

There are many similarities between the BSD and POSIX signal handling
facilities, because the POSIX facilities were inspired by the BSD
facilities.  Besides having different names for all the functions to
avoid conflicts, the main differences between the two are:

@itemize @bullet
@item
BSD Unix represents signal masks as an @code{int} bit mask, rather than
as a @code{sigset_t} object.

@item
BSD Unix provides hooks that let you control whether signals interrupt
system calls.  If a signal arrives during a system call (such as a read
or write operation that blocks the process), it may either return with
an @code{EINTR} error or be restarted.  POSIX provides no mechanism for
controlling this, but BSD does.
@cindex interrupted system call

@item
BSD Unix has a concept of a @dfn{signal stack}.  This is an alternate
stack that is used during the execution of signal handler functions,
instead of its normal execution stack.
@cindex signal stack
@end itemize

These facilities are declared in @file{signal.h}.
@pindex signal.h

@comment signal.h
@comment BSD
@deftypefn Macro int sigmask (int @var{signum})
This macro returns a signal mask that has the bit for signal @var{signum}
set.  You can bitwise-OR the results of several calls to @code{sigmask}
together to specify more than one signal.  For example,

@example
sigmask (SIGTSTP) | sigmask (SIGSTOP) |
sigmask (SIGTTIN) | sigmask (SIGTTOU)
@end example

@noindent
specifies a mask that includes all the job-control stop signals.
@end deftypefn

@comment signal.h
@comment BSD
@deftp {struct Type} sigvec
This data type is the equivalent of @code{struct sigaction}
(@pxref{Advanced Signal Handling}); it is used to specify signal actions
to the @code{sigvec} function.  It contains the following members:

@table @code
@item __sighandler_t sv_handler
This is the handler function.

@item int sv_mask
This is the mask of additional signals to be blocked while the handler
function is being called.

@item int sv_flags
This is a bit mask used to specify various flags which affect the
behavior of the signal.  You can also refer to this field as
@code{sv_onstack}.
@end table
@end deftp

These symbolic constants can be used to provide values for the
@code{sv_flags} field of a @code{sigvec} structure.  This field is a bit
mask value, so you bitwise-OR the flags of interest to you together.

@comment signal.h
@comment BSD
@deftypevr Macro int SV_ONSTACK
This macro can be used with the @code{sv_flags} field of a @code{sigvec}
structure, to specify that the signal stack should be used when delivering
the signal.
@end deftypevr

@comment signal.h
@comment BSD
@deftypevr Macro int SV_INTERRUPT
This macro can be used with the @code{sv_flags} field of a @code{sigvec}
structure, to specify that interrupted system calls should not be restarted.
If this flag is set, interrupted system calls return with a @code{EINTR}
error status.
@end deftypevr

@comment signal.h
@comment BSD
@deftypevr Macro int SV_RESETHAND
This macro can be used with the @code{sv_flags} field of a @code{sigvec}
structure, to specify that the action for the signal should be reset back
to @code{SIG_DFL} when the signal is received.
@end deftypevr

@comment signal.h
@comment BSD
@deftypefun int sigvec (int @var{signum}, const struct sigvec *@var{action},struct sigvec *@var{old_action})
This function is the equivalent of @code{sigaction} (@pxref{Advanced Signal
Handling}); it installs the action @var{action} for the signal @var{signum},
returning information about the previous action in effect for that signal
in @var{old_action}.
@end deftypefun

@comment signal.h
@comment BSD
@deftypefun int sigblock (int @var{mask})
This function is the equivalent of @code{sigprocmask} (@pxref{Process
Signal Mask}) with a @var{how} argument of @code{SIG_BLOCK}: it adds the
signals specified by @var{mask} to the calling process's signal mask.
The return value is the previous set of blocked signals.
@end deftypefun

@comment signal.h
@comment BSD
@deftypefun int sigsetmask (int @var{mask})
This function is the equivalent of @code{sigprocmask} (@pxref{Process
Signal Mask}) with a @var{how} argument of @code{SIG_SETMASK}: it sets
the calling process's signal mask to @var{mask}.  The return value is
the previous set of blocked signals.
@end deftypefun

@comment signal.h
@comment BSD
@deftypefun int sigpause (int @var{mask})
This function is the equivalent of @code{sigsuspend} (@pxref{Waiting
for a Signal}):  it sets the calling process's signal mask to @var{mask},
and waits for a signal to arrive.  On return the previous set of blocked
signals is restored.
@end deftypefun

@comment signal.h
@comment BSD
@deftypefun int siginterrupt (int @var{signum}, int @var{interrupt})
This function is used to change the system call interrupt behavior.  If
@var{interrupt} is false, system calls are restarted when
interrupted by receipt of the signal @var{signum}.  If @var{interrupt}
is true, system calls return with a @code{EINTR} error when
interrupted.
@end deftypefun

@comment signal.h
@comment BSD
@deftp {struct Type} sigstack
This structure describes a signal stack.  It contains the following members:

@table @code
@item void *ss_sp
This is the stack pointer.

@item int ss_onstack
This field is true if the process is currently using this stack.
@end table
@end deftp

@comment signal.h
@comment BSD
@deftypefun int sigstack (const struct sigstack *@var{stack}, struct sigstack *@var{oldstack})
The @code{sigstack} function selects an alternate stack for use during
signal handling.  When a signal is received by the process and its
action indicates that the signal stack is used, the system arranges a
switch to the currently installed signal stack while the handler for
that signal is executed.

If @var{oldstack} is not a null pointer, information about the currently
installed signal stack is returned in the location it points to.  If
@var{stack} is not a null pointer, then this is installed as the new
stack for use by signal handlers.

The return value is @code{0} on success and @code{1} on failure.
@end deftypefun

@strong{Incomplete:}  I don't think this is really enough information to
tell people how to use this facility.  Help!
