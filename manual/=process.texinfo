@node Processes
@chapter Processes

@cindex process
A @dfn{process} corresponds to the notion of a thread of control.  Each
process executes a program; you can have multiple processes executing
the same program, but each process has its own copy of the program
within its own address space.

Processes are organized hierarchically.  Child processes are created by
a parent process, and inherit many of their attributes from the parent
process.  Processes can also be organized into process groups or jobs.

This chapter describes how you can create and terminate processes and
control their attributes.

@menu
* Environment Variables::	How to access parameters inherited from
				 a parent process.
* Program Termination::		How to cause a process to terminate and
				 return status information to its parent.
* Creating New Processes::	Running other programs.
* User/Group IDs of a Process::	Controlling what privileges your program has.
* Process Information::		Miscellaneous functions for inquiring about
				 the execution environment of a process.
* System Parameters::		Constants and functions that describe
				 various process-related limits.
@end menu


@node Environment Variables
@section Environment Variables

@cindex environment variable
When a program is executed, it receives information about the context
in which it was invoked in two ways.  The first mechanism is 
the @var{argv} and @var{argc} arguments to its @code{main} function,
and the second mechanism is by means of @dfn{environment variables}.

The @var{argv} mechanism is typically used to pass information that is
specific to the particular program being invoked.  Typically, programs
do not share their command-line arguments.  The environment, on the
other hand, keeps track of information that is shared by many programs,
changes infrequently, and that is less frequently accessed.

@cindex environment
The names of environment variables are strings.  There are standard
environment variables that are used for information about the user's
home directory, terminal type, current locale, and so on; you can define
additional variables for other purposes.  The set of all environment
variables that have values is collectively known as the
@dfn{environment}.

@menu
* Environment Access::			The easy way to get the value of
					 an environment variable.
* Environment Representation::		Low-level implementation of
					 environments.
* Standard Environment Variables::	These environment variables have
					 standard interpretations.
@end menu

@node Environment Access
@subsection Environment Access
@cindex environment access

The value of an environment variable can be accessed with the
@code{getenv} function.  This is declared in the header file
@file{<stdlib.h>}.

@comment stdlib.h
@comment ANSI
@deftypefun {char *} getenv (const char *@var{name})
This function returns a string that is the value of the environment
variable @var{name}.  You must not modify this string, and it might be
overwritten by subsequent calls to @code{getenv} (but not by any other
library function).  If there is no environment variable named @var{name}
present, a null pointer is returned.
@end deftypefun


@node Environment Representation
@subsection Environment Representation
@cindex environment representation

You can deal directly with the underlying representation of environment
objects when you are going to add things to the environment (for
example, to communicate with another program you are about to execute;
@pxref{Executing a File}).  If you just want to get the value of an
environment variable, the preferred interface is the @code{getenv}
function.

This variable is not declared in any header file, but if you declare it
in your own program as @code{extern}, the right thing will happen.

@comment unistd.h
@comment POSIX.1
@deftypevar {char **} environ
The environment is represented as an array of strings.  Each string is
of the format @code{"@var{name}=@var{value}"}.  The order in which
strings appear in the environment is not significant, but the same
@var{name} must not appear more than once.  The last element of the
array is a null pointer.
@end deftypevar

Names of environment variables are case-sensitive and must not contain
the character @samp{=}.  System-defined environment variables are
invariably uppercase.

The values of environment variables can be anything that can be
represented as a string.  A value must not contain an embedded null
character, since this is assumed to terminate the string.

@comment stdlib.h
@comment SVID
@deftypefun int putenv (const char *@var{string})
The @code{putenv} function adds or removes definitions from the environment.
If the @var{string} is of the form @code{"@var{name}=@var{value}"}, the
definition is added to the environment.  Otherwise, the @var{string} is
interpreted as the name of an environment variable, and any definition
for this variable in the environment is removed.

The GNU library provides this function for compatibility with SVID; it
may not be available in other systems.
@end deftypefun

@node Standard Environment Variables
@subsection Standard Environment Variables

These environment variables have standard meanings.
This doesn't mean that they are always present in the
environment, though; it just means that if these variables @emph{are}
present, they have these meanings, and that you shouldn't try to use
these environment variable names for some other purpose.

@table @code
@item HOME
@cindex HOME environment variable
@cindex home directory
This is a string representing the user's @dfn{home directory}, or
initial default working directory.  @xref{User Database}, for a
more secure way of determining this information.

@item LOGNAME
@cindex LOGNAME environment variable
This is the name of the user's login account.  Since the value in the
environment can be tweaked arbitrarily, this is not the most reliable
way to identify the user who is running a process; a function like
@code{getlogin} (@pxref{User Identification}) is better for that
purpose.

@item PATH
@cindex PATH environment variable
This is a sequence of path prefixes which can be used to find a full
file name of a file name component, for the purposes of executing it.
The @code{execlp} and @code{execvp} functions (@pxref{Executing a File})
make use of this environment variable, as do many shells and other
utilities which are implemented in terms of those functions.

Each prefix is a file name which specifies a directory; an empty prefix
specifies the current working directory (@pxref{Working Directory}).
The prefixes are separated by colon (@samp{:}) characters.  In building
the full file names, a slash (@samp{/}) is glued between the prefix and
the file name component.

A typical value for this environment variable might be a string like:

@example
.:/bin:/etc:/usr/bin:/usr/new/X11:/usr/new:/usr/local:/usr/local/bin
@end example

@item TERM
@cindex TERM environment variable
This specifies the kind of terminal that is receiving program output.
Some programs can make use of this information to take advantage of
special escape sequences or terminal modes supported by particular kinds
of terminals.  Many programs which use the termcap library
(@pxref{Finding a Terminal Description,Find,,termcap,The Termcap Library
Manual}) use the @code{TERM} environment variable, for example.

@item TZ
@cindex TZ environment variable
This specifies the time zone.  @xref{Time Zone}, for information about
the format of this string and how it is used.

@item LANG
@cindex LANG environment variable
This specifies the default locale to use for attribute categories where
neither @code{LC_ALL} nor the specific environment variable for that
category is set.  @xref{Localization}, for more information about
locales.

@item LC_ALL
@cindex LC_ALL environment variable
This is similar to the @code{LANG} environment variable.  However, its
value takes precedence over any values provided for the individual
attribute category environment variables, or for the @code{LANG}
environment variable.

@item LC_COLLATE
@cindex LC_COLLATE environment variable
This specifies what locale to use, corresponding to the @code{LC_COLLATE}
attribute category.

@item LC_CTYPE
@cindex LC_CTYPE environment variable
This specifies what locale to use, corresponding to the @code{LC_CTYPE}
attribute category.

@item LC_MONETARY
@cindex LC_MONETARY environment variable
This specifies what locale to use, corresponding to the @code{LC_MONETARY}
attribute category.

@item LC_NUMERIC
@cindex LC_NUMERIC environment variable
This specifies what locale to use, corresponding to the @code{LC_NUMERIC}
attribute category.

@item LC_TIME
@cindex LC_TIME environment variable
This specifies what locale to use, corresponding to the @code{LC_TIME}
attribute category.
@end table

@node Program Termination
@section Program Termination
@cindex program termination
@cindex process termination

@cindex exit status value
The usual way for a program to terminate is simply for its @code{main}
function to return.  The @dfn{exit status value} returned from the
@code{main} function is used to report information back to the process's
parent process or shell.

A program can also be terminated normally using the @code{exit}
function, or aborted using the @code{abort} function.  Both of these
functions (as well as the normal return from @code{main}) are defined in
terms of a lower-level primitive, @code{_exit}.

In addition, programs can be terminated by signals; this is discussed in
more detail in @ref{Signal Handling}.

@menu
* Normal Program Termination::
* Aborting a Program::
* Process Termination Details::
@end menu

@node Normal Program Termination
@subsection Normal Program Termination

When a program terminates normally by returning from its @code{main}
function or by calling @code{exit}, the following actions occur in
sequence:

@itemize @bullet
@item 
Functions that were registered with the @code{atexit} or @code{on_exit}
functions are called in the reverse order of their registration.  This
mechanism allows your application to specify its own ``cleanup'' actions
to be performed at program termination.  Typically, this is used to do
things like saving program state information in a file, freeing any
resources allocated by the program, and the like.

@item 
All open streams are closed.  This action includes making sure all open
output streams are flushed.  In addition, temporary files opened with
the @code{tmpfile} function are removed.

@item 
Control is returned to the host environment, with the specified exit
status.
@end itemize

An exit status of zero or @code{EXIT_SUCCESS} can be specified to report
successful completion, and a status code of @code{EXIT_FAILURE} to
report unsuccessful completion.  Other status codes have
implementation-specific interpretations.

The following facilities are declared in @file{<stdlib.h>}.

@comment stdlib.h
@comment ANSI
@defvr Macro EXIT_SUCCESS
This macro can be used with the @code{exit} function to indicate
successful program completion.

In the GNU Library, the value of this macro is @code{0}.
In other implementations, the value might be some other (possibly
non-constant) integer expression.
@end defvr

@comment stdlib.h
@comment ANSI
@defvr Macro EXIT_FAILURE
This macro can be used with the @code{exit} function to indicate unsuccessful
program completion.

In the GNU Library, the value of this macro is @code{1}.  In other
implementations, the value might be some other (possibly non-constant)
integer expression.
@end defvr

@comment stdlib.h
@comment ANSI
@deftypefun void exit (int @var{status})
The @code{exit} function causes normal program termination with status
@var{status}.  This function does not return.
@end deftypefun

@comment stdlib.h
@comment ANSI
@deftypefun int atexit (void (*@var{function})(void))
The @code{atexit} function registers the function @var{function} to be
called at normal program termination.  The @var{function} is called with
no arguments.

The return value from @code{atexit} is zero on success and nonzero if
the function cannot be registered.  Implementations are required to
support registration of at least 32 functions.

@strong{Incomplete:}  What's the GNU limit, or isn't there one?
@end deftypefun

@comment stdlib.h
@comment GNU
@deftypefun int on_exit (void (*@var{function})(int @var{status}, void *@var{arg}), void *@var{arg})
This function is a somewhat more powerful variant of @code{on_exit}.  It
accepts two arguments, a function @var{function} and an arbitrary
pointer @var{arg}.  At normal program termination, the @var{function} is
called with two arguments:  the @var{status} value passed to @code{exit},
and the @var{arg}.

This function is a GNU extension, and may not be supported by other
implementations.
@end deftypefun

Here's a trivial program that illustrates the use of @code{exit} and
@code{atexit}:

@example
#include <stdio.h>
#include <stdlib.h>

void bye (void)
@{
  printf ("Goodbye, cruel world....\n");
@}

void main (void)
@{
  atexit (bye);
  exit (EXIT_SUCCESS);
@}
@end example

@noindent
When this program is executed, it just prints the message and exits.


@node Aborting a Program
@subsection Aborting a Program
@cindex aborting a program

You can abort your program using the @code{abort} function.  The prototype
for this function is in @file{<stdlib.h>}.

@comment stdlib.h
@comment ANSI
@deftypefun void abort (void)
The @code{abort} function causes abnormal program termination, without
executing functions registered with @code{atexit} or @code{on_exit}.

This function actually terminates the process by raising a
@code{SIGABRT} signal, and your program can include a handler to
intercept this signal; @pxref{Signal Handling}, for more information on
how to do this.
@end deftypefun

@node Process Termination Details
@subsection Process Termination Details

The @code{_exit} function is the primitive for both @code{exit} and
@code{abort}.  It is declared in the header file @file{<unistd.h>}.

@comment unistd.h
@comment POSIX.1
@deftypefun void _exit (int @var{status})
The @code{_exit} function is the primitive for causing a process to
terminate with status @var{status}.  Calling this function does not
execute functions registered with @code{atexit} or @code{on_exit}.
@end deftypefun

When a process terminates for any reason --- either by an explicit
termination call, or termination as a result of a signal --- the
following things happen:

@itemize @bullet
@item
All open file descriptors in the process are closed.  @xref{Low-Level
Input/Output}.

@item
The low-order 8 bits of the return status code are made available to
be reported back to the parent process via @code{wait} or @code{waitpid};
@pxref{Process Completion}.

@item
Any child processes of the process being terminated are assigned a new
parent process.  (This is the @code{init} process, with process ID 1.)

@item
A @code{SIGCHLD} signal is sent to the parent process (but only if the
implementation actually supports the @code{SIGCHLD} signal).

@item
If the process is a session leader that has a controlling terminal, then
a @code{SIGHUP} signal is sent to each process in the foreground job,
and the controlling terminal is disassociated from that session.
@xref{Job Control}.

@item
If termination of a process causes a process group to become orphaned,
and any member of that process group is stopped, then a @code{SIGHUP}
signal and a @code{SIGCONT} signal are sent to each process in the
group.  @xref{Job Control}.
@end itemize

@node Creating New Processes
@section Creating New Processes
@cindex creating new processes

This section describes how your program can cause other programs to be
executed.  Actually, there are three distinct operations involved:
creating a new child process, causing the new process to execute a
program, and coordinating the completion of the child process with the
original program.

The @code{system} function provides a simple, portable mechanism for
running another program.  If you need more control over the details of
how this is done, you can use the primitive functions to do
each step individually instead.

@menu
* Running a Command::		The easy way to run another program.
* Process Creation Concepts::	An overview of the hard way to do it.
* Creating a Process::		How to fork a child process.
* Executing a File::		How to get a process to execute another
				 program.
* Process Completion::		How to tell when a child process has
				 completed.
* Process Creation Example::    A complete example program.
@end menu


@node Running a Command
@subsection Running a Command
@cindex running a command

The easy way to run another program is to use the @code{system}
function.  This function does everything in one step, but it doesn't
give you as much control as doing each operation the hard way.

The @code{system} function is declared in the header file
@file{<stdlib.h>}.

@comment stdlib.h
@comment ANSI
@deftypefun int system (const char *@var{command})
This function is used to cause the command @var{command} to be executed.
The exact way in which this happens is implementation-dependent, as
is the return value from @code{system}.

In the GNU C Library, the @code{system} function uses the value of
the @code{PATH} environment variable to find the program to execute.
The return value is @code{-1} if it wasn't possible to create the
process, and otherwise is the status reported from the child process.
@xref{Process Completion}, for details on how this status code can
be interpreted.

Some C implementations may not have any notion of a command processor
that can execute other programs.  The @var{command} can be a null pointer
to inquire whether a command processor exists; in this case the return
value is nonzero if and only if such a processor is available.
@end deftypefun

The @code{popen} and @code{pclose} functions (@pxref{Pipe to a
Subprocess}) are closely related to the @code{system} function.  They
allow the parent process to communicate with the standard input and
output channels of the @var{command} being executed.

@node Process Creation Concepts
@subsection Process Creation Concepts

This section gives an overview of what's involved in using the low-level
functions directly to create a process and have it run a program.  

@cindex process ID
@cindex process lifetime
Each process is named by a @dfn{process ID}.  A unique process ID is
allocated to each process when it is created.  The @dfn{lifetime} of a
process ends when its termination is reported to its parent process; at
that time, all of the process resources, including its process ID, are
returned to the system.

@cindex creating a process
@cindex forking a process
@cindex child process
@cindex parent process
Processes are created with the @code{fork} system call (so the operation
of creating a new process is sometimes called @dfn{forking} a process).
The @dfn{child process} created by @code{fork} is an exact clone of the
original @dfn{parent process}, except that it has its own process ID.

After forking a child process, both the parent and child processes
continue to execute normally.  If you want your program to wait for a
child process to finish executing before continuing, you must do this
explicitly after the fork operation.  This is done with the @code{wait}
or @code{waitpid} functions.  The status code with which the child
process terminated is also retrieved by these functions.

A newly forked child process continues to execute the same program as
its parent process, at the point where the @code{fork} call returns.
Having all processes run the same program is usually not very useful,
but if you want the new process to execute a different program you must
do this explicitly too.  

@cindex process image
The functions in the @code{exec} family are used to cause the current
process to begin execution of a new program.  The program that the
process is executing is called its @dfn{process image}.  Starting
execution of a new program causes the process to forget all about its
current process image; when the new program exits, the process exits
too, instead of returning to the previous process image.

@node Creating a Process
@subsection Creating a Process

The @code{fork} function is the primitive for creating a process.
It is declared in the header file @file{<unistd.h>}.

@comment sys/types.h
@comment POSIX.1
@deftp {Data Type} pid_t
The @code{pid_t} data type is a signed arithmetic type which is capable
of representing a process ID.
@end deftp

@comment unistd.h
@comment POSIX.1
@deftypefun pid_t fork (void)
The @code{fork} function creates a new process.

If the operation is successful, @code{fork} returns a value of @code{0}
to the child process and the process ID of the newly created process to
the parent process.  If the child process could not be created, a value
of @code{-1} is returned to the parent process.  The following @code{errno}
error conditions are defined for this function:

@table @code
@item EAGAIN
There aren't enough system resources to create another process, or the
user already has too many processes running.

@item ENOMEM
The process requires more space than the system can supply.
@end table
@end deftypefun

The specific attributes of the child process that differ from the
parent process are:

@itemize @bullet
@item
The child process has its own unique process ID.

@item
The parent process ID of the child process is the process ID of its
parent process.

@item
The child process gets its own copies of the parent process's open file
descriptors.  Changing attributes of the file descriptors in the parent
process won't change the file descriptors in the child, and vice versa.
@xref{Control Operations on Files}.

@item
The elapsed processor times for the child process are set to zero;
@pxref{Processor Time}.

@item
The child doesn't inherit file locks set by the parent process.
@xref{Control Operations on Files}.

@item
The child doesn't inherit alarms set by the parent process.
@xref{Setting an Alarm}.

@item
The set of pending signals (@pxref{Signal Concepts}) for the child
process is cleared.
@end itemize 


@comment unistd.h
@comment BSD
@deftypefun pid_t vfork (void)
The @code{vfork} function is similar to @code{fork} but can be used only
in a more restricted way.  In the situations where it can be used, however,
it is usually more efficient than @code{fork}.

While @code{fork} makes a complete copy of the calling process's address
space and allows both the parent and child to execute independently,
@code{vfork} does not make this copy.  Instead, the child process
created with @code{vfork} shares its parent's address space until it calls
one of the @code{exec} functions.  In the meantime, the parent process
suspends execution.

In typical use, @code{vfork} is used only if the child process immediately
calls @code{exec}.  You must be very careful if the child process does
anything else.  In particular, the child process cannot return from (or
do a long jump out of) the function that called @code{vfork}!  This would
leave the parent process's control information very confused.  If in
doubt, use @code{fork} instead.
@end deftypefun

@node Executing a File
@subsection Executing a File

This section describes the @code{exec} family of functions, for executing
a file as a process image.  There are several variants that allow you to
specify the arguments in different ways, but otherwise they all work in
pretty much the same way.

These facilities are declared in the header file @file{<unistd.h>}.

@comment unistd.h
@comment POSIX.1
@deftypefun int execv (const char *@var{filename}, char *const @var{argv}[])
The @code{execv} function executes the file named by @var{filename} as a
new process image.

The @var{argv} argument is an array of null-terminated strings that is
used to provide a value for the @code{argv} argument to the @code{main}
function of the program to be executed.  The last element of this array
must be a null pointer.

The environment for the new process image is taken from the
@code{environ} variable of the current process image; @pxref{Environment
Variables}, for information about environments.
@end deftypefun

@comment unistd.h
@comment POSIX.1
@deftypefun int execl (const char *@var{filename}, const char *@var{arg0}, @dots{})
This is similar to @code{execv}, but the @var{argv} strings are
specified individually instead of as an array.  A null pointer must be
passed as the last such argument.
@end deftypefun

@comment unistd.h
@comment POSIX.1
@deftypefun int execve (const char *@var{filename}, char *const @var{argv}[], char *const @var{env}[])
This is similar to @code{execv}, but permits you to specify the environment
for the new program explicitly as the @var{env} argument.  This should
be an array of strings in the same format as for the @code{environ} 
variable; @pxref{Environment Representation}.
@end deftypefun

@comment unistd.h
@comment POSIX.1
@deftypefun int execle (const char *@var{filename}, const char *@var{arg0}, @dots{})
This is similar to @code{execl}, but permits you to specify the
environment for the new program explicitly.  The environment argument is
passed following the null pointer that marks the last @var{argv}
argument, and should be an array of strings in the same format as for
the @code{environ} variable.
@end deftypefun

@comment unistd.h
@comment POSIX.1
@deftypefun int execvp (const char *@var{filename}, char *const @var{argv}[])
The @code{execvp} function is similar to @code{execv}, except that it
uses the @code{PATH} environment variable (@pxref{Standard Environment
Variables}) to find the full file name of a file whose name is
@var{filename}.  If the @var{filename} does not contain a directory
specification, the directories specified in the file name list are
searched in left-to-right order for a file with this name.

This function is primarily intended for use by shells and the like,
where the name of the program to be executed is provided by the user as
input to the program.  If you want to execute a particular program, you
are better off supplying a full file name.  That avoids the
possibility of some other program accidentally getting run instead
because of the user of your program having the wrong @code{PATH}
configuration.
@end deftypefun

@comment unistd.h
@comment POSIX.1
@deftypefun int execlp (const char *@var{filename}, const char *@var{arg0}, @dots{})
This function is like @code{execl}, except that it performs the same
file name searching as the @code{execvp} function.
@end deftypefun


The size of the argument list and environment list taken together must not
be greater than @code{ARG_MAX} bytes.  @xref{System Parameters}.

@strong{Incomplete:}  The POSIX.1 standard requires some statement here
about how null terminators, null pointers, and alignment requirements
affect the total size of the argument and environment lists.

These functions normally don't return, since execution of a new program
causes the currently executing program to go away completely.  A value
of @code{-1} is returned in the event of a failure.  In addition to the
usual file name syntax errors (@pxref{File Name Errors}), the following
@code{errno} error conditions are defined for these functions:

@table @code
@item E2BIG
The combined size of the new program's argument list and environment list
is larger than @code{ARG_MAX} bytes.

@item ENOEXEC
The specified file can't be executed because it isn't in the right format.

@item ENOMEM
Executing the specified file requires more storage than is available.
@end table

If execution of the new file is successful, the access time field of the
file is updated and the file is considered to have been @code{open}ed.
@xref{File Times}, for more details about access times of files.

The point at which the file is @code{close}d again is not specified, but
is at some point before the process exits or before another process
image is executed.

The new process image inherits at least the following attributes
from the existing image:

@itemize @bullet
@item
The process ID, parent process ID, and process group ID.  @xref{Process Creation Concepts}, and @ref{Job Control Concepts}.

@item
Session membership.  @xref{Job Control Concepts}.

@item
Real user ID and group ID, and supplementary group IDs.  @xref{User/Group
IDs of a Process}.

@item
Pending alarms.  @xref{Setting an Alarm}.

@item
Current working directory and root directory.  @xref{Working Directory}.

@item
File mode creation mask.  @xref{Assigning File Permissions}.

@item
Process signal mask; @pxref{Process Signal Mask}.

@item
Pending signals; @pxref{Blocking Signals}.

@item
Elapsed processor time associated with the process; @pxref{Processor Time}.
@end itemize

If the set-user-ID and set-group-ID mode bits of the process image file
are set, this affects the effective user ID and effective group ID
(respectively) of the process.  These concepts are discussed in detail
in @ref{User/Group IDs of a Process}.

File descriptors open in the existing process image remain open in the
new process image, unless they have the @code{FD_CLOEXEC}
(close-on-exec) flag set.  The files that remain open inherit all
attributes of the open file description from the existing process image,
including file locks.  File descriptors are discussed in @ref{Low-Level
Input/Output}.

Signals that are set to be ignored in the existing process image are
also set to be ignored in the new process image.  All other signals are
set to the default action in the new process image.  For more
information about signals, @pxref{Signal Handling}.

@node Process Completion
@subsection Process Completion
@cindex process completion
@cindex waiting for completion of child process
@cindex testing exit status of child process

The functions described in this section are used to determine the status
of a child process.  These functions are declared in the header file
@file{<sys/wait.h>}.


@comment sys/wait.h
@comment POSIX.1
@deftypefun pid_t waitpid (pid_t @var{pid}, int *@var{status_ptr}, int @var{options})
The @code{waitpid} function is used to request status information from a
child process whose process ID is @var{pid}.  Normally, the calling
process is suspended until the child process makes status information
available by terminating.

Other values for the @var{pid} argument have special interpretations.
A value of @code{-1} requests status information for any child process;
a value of @code{0} requests information for any child process in the
same process group as the calling process; and any other negative value
requests information for any child process whose process group ID is the
absolute value of that number.  

If status information for a child process is available immediately, this
function returns immediately without waiting.  If more than one child
process has status information available, the order in which they report
their status is not specified.

The @var{options} argument is a bit mask.  Its value should be the
bitwise exclusive OR (that is, the @samp{|} operator) of zero or more of
the @code{WNOHANG} and @code{WUNTRACED} flags.  You can use the
@code{WNOHANG} flag to indicate that the parent process shouldn't be
suspended, and the @code{WUNTRACED} flag to request status information
from stopped processes as well as processes that have terminated.

The status information from the child process is stored in the object
that @var{status_ptr} points to, unless @var{status_ptr} is a null pointer.

The return value is normally the process ID of the child process whose
status is reported.  If the @code{WNOHANG} option was specified and
status information is not currently available for any child process, a
value of zero is returned.  A value of @code{-1} is returned in case
of error.  The following @code{errno} error conditions are defined for
this function:

@table @code
@item EINTR
The function was interrupted by delivery of a signal to the calling
process.

@item ECHILD
There are no child processes to wait for, or the specified @var{pid}
is not a child of the calling process.

@item EINVAL
An invalid value was provided for the @var{options} argument.
@end table
@end deftypefun

These symbolic constants are defined as flags for the @var{options}
argument to the @code{wait} function.

@comment sys/wait.h
@comment POSIX.1
@defvr {Macro} WNOHANG
This macro is used to specify that @code{waitpid} should return
immediately instead of suspending execution if there is no status
information immediately available.
@end defvr

@comment sys/wait.h
@comment POSIX.1
@defvr {Macro} WUNTRACED
This macro is used to specify that @code{waitpid} should also report the
status of any child processes that are stopped but whose status hasn't
been reported since they were stopped.
@end defvr

@comment sys/wait.h
@comment POSIX.1
@deftypefun pid_t wait (int *@var{status_ptr})
This is a simplified version of @code{waitpid}, and is used to suspend
program execution until any child process terminates.

@example
wait (&status)
@end example

@noindent
is equivalent to:

@example
waitpid (-1, &status, 0)
@end example
@end deftypefun

If the exit status value (@pxref{Program Termination}) of the child
process is zero, then the status value reported by @code{waitpid} or
@code{wait} is also zero.  You can test for other kinds of information
encoded in the returned status value using the following macros.

@comment sys/wait.h
@comment POSIX.1
@deftypefn Macro int WIFEXITED (int @var{status})
This macro returns a non-zero value if the child process terminated
normally.
@end deftypefn

@comment sys/wait.h
@comment POSIX.1
@deftypefn Macro int WEXITSTATUS (int @var{status})
This macro can be used if @code{WIFEXITED} is true of @var{status}.  It
returns the low-order 8 bits of the exit status value from the child
process.
@end deftypefn

@comment sys/wait.h
@comment POSIX.1
@deftypefn Macro int WIFSIGNALED (int @var{status})
This macro returns a non-zero value if the child process terminated
by receiving a signal that was not caught.
@end deftypefn

@comment sys/wait.h
@comment POSIX.1
@deftypefn Macro int WTERMSIG (int @var{status})
This macro can be used if @code{WIFSIGNALED} is true of @var{status}.
It returns the number of the signal that terminated the child process.
@end deftypefn

@comment sys/wait.h
@comment POSIX.1
@deftypefn Macro int WIFSTOPPED (int @var{status})
This macro returns a non-zero value if the child process is stopped.
@end deftypefn

@comment sys/wait.h
@comment POSIX.1
@deftypefn Macro int WSTOPSIG (int @var{status})
This macro can be used if @code{WIFSTOPPED} is true of @var{status}.  It
returns the number of the signal that caused the child process to stop.
@end deftypefn


The GNU Library also provides these related facilities for compatibility
with BSD Unix.  BSD uses the @code{union wait} data type to represent
status values rather than an @code{int}.  The two representations are
actually interchangable.  The macros such as @code{WEXITSTATUS} are
defined so that they will work on either kind of object, and the
@code{wait} function is defined to accept either type of pointer as its
@var{status_ptr} argument.

@comment sys/wait.h
@comment BSD
@deftp {Data Type} {union wait}
This data type represents program termination status values.

@strong{Incomplete:}  The header file has some definitions for the members
of this union.  Do they need to be documented?
@end deftp

@comment sys/wait.h
@comment BSD
@deftypefun pid_t wait3 (union wait *@var{status_ptr}, int @var{options}, void * @var{usage})
If @var{usage} is a null pointer, this function is equivalent to
@code{waitpid (-1, @var{status_ptr}, @var{options})}.

The @var{usage} argument may also be a pointer to a 
@code{struct rusage} object.  Information about system resources used by
terminated processes (but not stopped processes) is returned in this
structure.  @xref{wherever}.
@end deftypefun

@comment sys/wait.h
@comment BSD
@deftypefun pid_t wait4 (pid_t @var{pid}, union wait *@var{status_ptr}, int @var{options}, void *@var{usage})
If @var{usage} is a null pointer, this function is equivalent to
@code{waitpid (@var{pid}, @var{status_ptr}, @var{options})}.

The @var{usage} argument may also be a pointer to a 
@code{struct rusage} object.  Information about system resources used by
terminated processes (but not stopped processes) is returned in this
structure.  @xref{wherever}.
@end deftypefun

@node Process Creation Example
@subsection Process Creation Example

Here is an example program showing how a function similar to the
built-in @code{system} function might be implemented.  It executes its
@var{command} argument using the equivalent of @samp{sh -c @var{command}}.

@example
#include <stddef.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

/* Execute the command using this shell program.  */
#define SHELL "/bin/sh"

int 
my_system (char *command)
@{
  int status;
  pid_t pid;

  pid =  fork();
  if (pid == (pid_t) 0) @{
    /* This is the child process.  Execute the shell command. */
    (void) execl (SHELL, SHELL, "-c", command, NULL);
    exit (EXIT_FAILURE);
    @}
  else if (pid < (pid_t) 0)
    /* The fork failed.  Report failure.  */
    status = -1;
  else @{
    /* This is the parent process.  Wait for the child to complete.  */
    if (waitpid (pid, &status, 0) != pid)
      status = -1;
    @}
  return status;
@}
@end example

@comment Yes, this example has been tested.

There are a couple of things you should pay attention to in this
example.

Remember that the first @code{argv} argument supplied to the program
represents the name of the program being executed.  That is why, in the
call to @code{execl}, @code{SHELL} is supplied once to name the program
to execute and a second time to supply a value for @code{argv[0]}.  

The @code{exec} call in the child process doesn't return if it is
successful.  If it fails, you must do something to make the child
process terminate.  Just returning a bad status code with @code{return}
would leave two processes running the original program.  Instead, the
right behavior is for the child process to report failure to its parent
process.  To do this, @code{exit} is called with a failure status.

@node User/Group IDs of a Process
@section User/Group IDs of a Process

@cindex process ownership
@cindex process user ID
@cindex user ID, of a process
@cindex process group ID
@cindex group ID, of a process
@cindex @code{setuid} program
@cindex @code{setgid} program

The accessibility of system resources (such as files) by a process is
determined by the user and group IDs of the process and the protections
or modes associated with the resource.  Normally, a process inherits its
user and group IDs from its parent process, but a program can change
them so that it can access resources that wouldn't otherwise be
available to it.  This section describes how to do this.

@menu
* Process User and Group IDs::		Defines terms and concepts.
* Changing the User or Group ID::	Why a program might need to change
					 its user and/or group IDs.
* Controlling Process Privileges::	Restrictions on how the user and
					 group IDs can or should be changed.
* User and Group ID Functions::		Detailed specification of the
					 interface.
* Setuid Program Example::		A detailed example.
@end menu

@node Process User and Group IDs
@subsection Process User and Group IDs

@cindex login name
@cindex user name
@cindex user ID
Each user account on a computer system is identified by a @dfn{user
name} (or @dfn{login name}) and @dfn{user ID}.  These are assigned by
the system administrator when the account is created in the system user
database.  Normally, each login name in the database has a unique user
ID, but it is possible for multiple login names to be associated with a
single user ID.

@cindex group name
@cindex group ID
The system administrator is also responsible for establishing which
groups a user belongs to.  Users who are members of the same group can
share resources (such as files) that are not accessible to users who are
not a member of that group.  Each group has a @dfn{group name} and
@dfn{group ID}.

When you log in to the computer, the processes that you create are
assigned your user ID and your default group ID.  But an individual
program can change the user and group IDs of the process that is running
in; @pxref{Changing the User or Group ID}, for information about why
a program would want to do this.

@cindex effective user ID
@cindex real user ID
A particular process actually has two user IDs associated with it.  The
@dfn{real user ID} identifies the user who created the process.  The
@dfn{effective user ID}, on the other hand, is used to determine
permissions for accessing resources such as files.  Both the real and
effective user ID can be changed during the lifetime of a process.

@cindex real group ID
@cindex effective group ID
@cindex supplementary group IDs
Similarly, an individual process has both @dfn{real group ID} and
@dfn{effective group ID} attributes.  In addition, since a user can
belong to multiple groups, the additional groups that can affect
permissions are referred to as @dfn{supplementary group IDs}.

For details on how a process's user IDs and group IDs affect its
permission to access files, @pxref{Permission to Access a File}.  For
more information about the system user and group databases,
@pxref{System Databases}.

The user ID of a process also controls permissions for sending signals
using the @code{kill} function.  @xref{Signaling Another Process}.



@node Changing the User or Group ID
@subsection Changing the User or Group ID

The most obvious situation where it is necessary for a process to change
its user and/or group IDs is in a system login-type program.  Such a
program creates processes and sets both the real and effective user and
group IDs to match those of the user who is logging in.

Some ordinary user programs need to use an effective user or group ID
that corresponds to something other than the user who is actually
running the program, too.  This permits the program to use a resource
that wouldn't otherwise be accessible to the user who runs it.  This
situation most commonly arises when you want to have a file that is
controlled by your program but that shouldn't be read or modified
directly by ordinary users, either because it implements some kind of
locking protocol, or because you want to be careful to preserve the
integrity or privacy of the information it contains.  This kind of
restricted access can be implemented by having the program change its
user or group ID to be the same as the owner of the resource.

As an example, some game programs use a file to keep track of high
scores and the like.  The game program itself obviously needs to be able
to update this file no matter who is running it, but users shouldn't be
allowed to write to the file directly --- otherwise people might cheat
and give themselves outrageously high scores!  The solution is to create
a new user ID and login name (say, @samp{games}) to own the scores
file, and make the file writable only by this user.  Then, when the game
program wants to update this file, it can change its effective user ID
to be that for @samp{games}.

Another example of a resource that commonly has restricted access is a
dialout modem port, where you would like to have all programs that make
use of the port record some information so that phone calls can be
billed to the correct user.  In fact, system programs such as @code{tip}
and @code{uucp} do use just such a mechanism.


@node Controlling Process Privileges
@subsection Controlling Process Privileges

The ability to set the user ID of a process is very powerful facility
and can be a source of unintentional privacy or security violations, or
even intentional abuse by antisocial users.  Because of the potential
for problems, there are a number of restrictions on how nonprivileged
programs can use the facilities, and some voluntary guidelines you
should follow.

You can't just arbitrarily set your user ID or group ID to anything you
want; only privileged users can do that.  Permission for a program being
run by an ordinary user to change to another user or group ID has to be
granted explicitly by that user or group.  This is done by setting the
modes on the executable file for the program in a special way.

When you execute a file (@pxref{Executing a File}) that has the
set-user-ID mode bit set, then the effective user ID of the process is
set to the owner of the file.  Likewise, if the set-group-ID mode bit of
the file being executed is set, then the effective group ID of the
process is set to the group owner of the file.  (Files that have these
bits set are often referred to as @code{setuid} or @code{setgid}
programs, respectively.)

@xref{File Attributes}, for a more general discussion of file modes and
accessibility.

Even with this restriction, it is still possible for @code{setuid} or
@code{setgid} programs to get into trouble.  There are a few
things you can do in order to minimize the potential for problems in
your own programs:

@itemize @bullet
@item
Don't have @code{setuid} programs owned by privileged accounts such as
@samp{root} or @samp{superuser}, unless it is absolutely necessary.  If
the resource is specific to your particular program, it's better to
define a new, nonprivileged user ID just to manage that resource.

@item
Be cautious about using the @code{system} and @code{exec} functions in
combination with changing the effective user ID.  Don't let users of
your program execute arbitrary programs under a changed user ID.
Executing a shell is especially bad news.  Less obviously, the
@code{execlp} and @code{execvp} functions are a potential source of
abuse (since the program they execute depends on the user's @code{PATH}
environment variable).

If you must @code{exec} another program under a changed ID, specify
an absolute file name (@pxref{File Name Resolution}) for the executable,
and make sure that the protections on that executable and its directory
are such that ordinary users cannot replace it with some other program.

@item
Only use the user ID controlling the resource in the part of the program
that actually uses that resource.  When you're finished with it, restore
the effective user ID back to the user's real user ID.

@item
If the @code{setuid} part of your program needs to access ordinary files
as well as the controlled resource, make sure that the user would
ordinarily have permission to access those files.  You can use the
@code{access} function (@pxref{Permission to Access a File}) to make
this determination; it uses the real user and group IDs, rather than the
effective IDs.
@end itemize


@node User and Group ID Functions
@subsection User and Group ID Functions

Here are detailed descriptions of the functions for inquiring about or
changing the user and group IDs of a process.  To use these facilities,
you must include the header files @file{<sys/types.h>} and
@file{<unistd.h>}.

@comment sys/types.h
@comment POSIX.1
@deftp {Data Type} uid_t
This is an arithmetic data type used to represent user IDs.
@end deftp

@comment sys/types.h
@comment POSIX.1
@deftp {Data Type} gid_t
This is an arithmetic data type used to represent group IDs
@end deftp

@comment unistd.h
@comment POSIX.1
@deftypefun uid_t getuid (void)
The @code{getuid} function returns the real user ID of the process.
@end deftypefun

@comment unistd.h
@comment POSIX.1
@deftypefun gid_t getgid (void)
The @code{getgid} function returns the real group ID of the process.
@end deftypefun

@comment unistd.h
@comment POSIX.1
@deftypefun uid_t geteuid (void)
The @code{geteuid} function returns the effective user ID of the process.
@end deftypefun

@comment unistd.h
@comment POSIX.1
@deftypefun gid_t getegid (void)
The @code{getegid} function returns the effective group ID of the process.
@end deftypefun

@comment unistd.h
@comment POSIX.1
@deftypefun int getgroups (int @var{count}, gid_t *@var{groups})
The @code{getgroups} function is used to inquire about the supplementary
group IDs of the process.  Up to @var{count} of these group IDs are
stored in the array @var{groups}; the return value from the function is
the number of group IDs actually stored.  If @var{count} is smaller than
the total number of supplementary group IDs, then @code{getgroups}
returns a value of @code{-1} and @code{errno} is set to @code{EINVAL}.

If @var{count} is zero, then @code{getgroups} just returns the total
number of supplementary group IDs.

The effective group ID of the process might or might not be included in
the list of supplementary group IDs.
@end deftypefun


@comment unistd.h
@comment POSIX.1
@deftypefun int setuid (@var{newuid})
This function sets both the real and effective user ID of the process
to @var{newuid}, provided that the process has appropriate privileges.

If the process is not privileged, then @var{newuid} must either be equal
to the real user ID or the saved user ID from the program's image file
(but only if the implementation supports the @code{_POSIX_SAVED_IDS}
feature).  In this case, @code{setuid} sets only the effective user ID
and not the real user ID.

The @code{setuid} function returns a value of @code{0} to indicate
successful completion, and a value of @code{-1} to indicate an error.
The following @code{errno} error conditions are defined for this
function:

@table @code
@item EINVAL
The value of the @var{newuid} argument is invalid.

@item EPERM
The process does not have the appropriate privileges.
@end table
@end deftypefun

@comment unistd.h
@comment BSD
@deftypefun int setreuid (int @var{ruid}, int @var{euid})
This function sets the real user ID of the process to @var{ruid} and
the effective user ID to @var{euid}.

The @code{setreuid} function is provided for compatibility with 4.2 BSD
Unix, which does not support saved IDs.  You can use this function to
swap the effective and real user IDs of the process.  (Privileged users
can make other changes as well.)  If saved IDs are supported, you should
make use of that feature instead of using this function.

The return value is @code{0} on success and @code{-1} on failure.
The following @code{errno} error conditions are defined for this
function:

@table @code
@item EPERM
The process does not have the appropriate privileges.  
@end table
@end deftypefun

@comment unistd.h
@comment POSIX.1
@deftypefun int setgid (@var{newgid})
This function sets both the real and effective group ID of the process
to @var{newgid}, provided that the process has appropriate privileges.

If the process is not privileged, then @var{newgid} must either be equal
to the real group ID or the saved group ID from the program's image
file.  In this case, @code{setgid} sets only the effective group ID and
not the real group ID.

The return values and error conditions for @code{setgid} are the same
as those for @code{setuid}.
@end deftypefun


@comment unistd.h
@comment BSD
@deftypefun int setregid (int @var{rgid}, int @var{egid})
This function sets the real group ID of the process to @var{rgid} and
the effective group ID to @var{egid}.

The @code{setregid} function is provided for compatibility with 4.2 BSD
Unix, which does not support saved IDs.  You can use this function to
swap the effective and real group IDs of the process.  (Privileged users
can make other changes.)  If saved IDs are supported, you should make use 
of that feature instead of using this function.

The return values and error conditions for @code{setregid} are the same
as those for @code{setreuid}.
@end deftypefun

The GNU system also lets privileged processes change their supplementary 
group IDs.  To use @code{setgroups} or @code{initgroups}, your programs
should include the header file @file{<grp.h>}.

@comment grp.h
@comment BSD
@deftypefun int setgroups (size_t @var{count}, gid_t *@var{groups})
This function sets the process's supplementary group IDs.  It can only
be called from privileged processes.  The @var{count} argument specifies
the number of group IDs in the array @var{groups}.

This function returns @code{0} if successful and @code{-1} on error.
The following @code{errno} error conditions are defined for this
function:

@table @code
@item EPERM
The calling process is not privileged.
@end table
@end deftypefun

@comment grp.h
@comment BSD
@deftypefun int initgroups (const char *@var{user}, gid_t @var{gid})
The @code{initgroups} function effectively calls @code{setgroups} to
set the process's supplementary group IDs to be the normal default for
the user name @var{user}.  The group ID @var{gid} is also included.
@end deftypefun

@node Setuid Program Example
@subsection Setuid Program Example

Here's an example showing how to set up a program that changes its
effective user ID.

This is part of a game program called @code{caber-toss} that wants to
manipulate a file @file{scores} that should only be writable by the game
program itself.  The program is written assuming that the executable
file will be installed with the set-user-ID bit set and owned by the
same user as the resource it wants to access.  Typically, a system
administrator will set up an account like @samp{games} for this purpose.

The executable file is given mode @code{4755}, so that doing an 
@samp{ls -l} on it produces output like:

@example
-rwsr-xr-x   1 games    184422 Jul 30 15:17 caber-toss*
@end example

@noindent
The set-user-ID bit shows up in the file modes as the @samp{s}.

The scores file is given mode @code{644}, and doing an @samp{ls -l} on
it shows:

@example
-rw-r--r--  1 games           0 Jul 31 15:33 scores
@end example

Here are the parts of the program that show how to set up the changed
user ID.  This program is conditionalized so that it makes use of the
saved IDs feature if it is supported, and otherwise uses @code{setreuid}
to swap the effective and real user IDs.

@example
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>


/* @r{Save the effective and real UIDs.} */

uid_t euid, ruid;


/* @r{Restore the effective UID to its original value.} */

void do_setuid (void)
@{
  int status;

#ifdef _POSIX_SAVED_IDS
  status = setuid (euid);
#else
  status = setreuid (ruid, euid);
#endif
  if (status < 0) @{
    fprintf (stderr, "Couldn't set uid.\n");
    exit (status);
    @}
@}


/* @r{Set the effective UID to the real UID.} */

void undo_setuid (void)
@{
  int status;

#ifdef _POSIX_SAVED_IDS
  status = setuid (ruid);
#else
  status = setreuid (euid, ruid);
#endif
  if (status < 0) @{
    fprintf (stderr, "Couldn't set uid.\n");
    exit (status);
    @}
@}


/* @r{Main program.} */

void main (void)
@{
  /* @r{Save the real and effective user IDs.}  */
  ruid = getuid ();
  euid = geteuid ();
  undo_setuid ();

  /* @r{Do the game and record the score.}  */
  @dots{}
@}
@end example

Notice how the first thing the @code{main} function does is to set the
effective user ID back to the real user ID.  Only when the program needs
to open the scores file does it switch back to the original effective
user ID, like this:

@example
/* @r{Record the score.} */

int record_score (int score)
@{
  FILE *stream;
  char *myname;

  /* @r{Open the scores file.} */
  do_setuid ();
  stream = fopen (SCORES_FILE, "a");
  undo_setuid ();

  /* @r{Write the score to the file.} */
  if (stream) @{
    myname = cuserid (NULL);
    if (score < 0)
      fprintf (stream, "%10s: Couldn't lift the caber.\n", myname);
    else
      fprintf (stream, "%10s: %d feet.\n", myname, score);
    fclose (stream);
    return 0;
    @}
  else
    return -1;
@}
@end example


@node Process Information
@section Process Information

This section describes functions you can use to inquire about various
attributes of the process, including information about the user who
is running the program and what terminal and computer system it is
running on.

@menu
* Process Identification::
* User Identification::
* System Identification::
* Controlling Terminal Identification::
@end menu

@node Process Identification
@subsection Process Identification

If you want to use these functions, your program should include the
header files @file{<unistd.h>} and @file{<sys/types.h>}.

@comment unistd.h
@comment POSIX.1
@deftypefun pid_t getpid (void)
The @code{getpid} function returns the process ID of the currrent process.
@end deftypefun

@comment unistd.h
@comment POSIX.1
@deftypefun pid_t getppid (void)
The @code{getppid} function returns the process ID of the parent of the
current process.
@end deftypefun

@node User Identification
@subsection User Identification

These functions can be used to determine the login name of the user who
is running a process.  You can also use @code{getuid} and friends
(@pxref{User and Group ID Functions}) to determine the user and group ID
of user who is running a process, and functions such as @code{getpwnam}
(@pxref{System Databases}) to get information about the user from the system
password database.

The @code{getlogin} function is declared in @file{<unistd.h>}, while
@code{cuserid} and @code{L_cuserid} are declared in @file{<stdio.h>}.

@comment unistd.h
@comment POSIX.1
@deftypefun {char *} getlogin (void)
The @code{getlogin} function returns a pointer to string containing the
name of the user logged in on the controlling terminal of the process,
or a null pointer if this information cannot be determined.  The string
is statically allocated and might be overwritten on subsequent calls to
this function or to @code{cuserid}.
@end deftypefun

@comment stdio.h
@comment POSIX.1
@deftypefun {char *} cuserid (@var{string})
The @code{cuserid} function returns a pointer to a string containing a
name associated with the effective ID of the process.  If @var{string}
is not a null pointer, it should be an array that can hold at least
@code{L_cuserid} characters; the string is returned in this array.
Otherwise, a pointer to a string in a static area is returned.  This
string is statically allocated and might be overwritten on subsequent
calls to this function or to @code{getlogin}.
@end deftypefun

@comment stdio.h
@comment POSIX.1
@defvr Macro L_cuserid
The value of this macro is an integer constant expression that
is the size of a string large enough to store a login name.
@end defvr


@node System Identification
@subsection System Identification

You can use the @code{uname} function to find out some information about
the computer system your program is running on.  This function and the
associated data type are declared in the header file
@file{<sys/utsname.h>}.

@comment sys/utsname.h
@comment POSIX.1
@deftp {Data Type} {struct utsname}
The @code{utsname} structure is used to hold information returned
by the @code{uname} function.  It has the following members:

@table @code
@item {char sysname[]}
This is the name of the operating system implementation.  In the
GNU Library, the value is the string @code{"GNU C Library"}.
@item {char nodename[]}
This is the name of this node within a communications network.  In the
GNU Library, the value is the same as that returned by
@code{gethostname}; @pxref{wherever}.
@item {char release[]}
This is the current release level of the operating system implementation.
@item {char version[]}
This is the current version level within the release of the operating
system.
@item {char machine[]}
This is a description of the hardware type that the operating system
is running on.
@end table
@end deftp


@comment sys/utsname.h
@comment POSIX.1
@deftypefun int uname (struct utsname *@var{info})
The @code{uname} function fills in the structure pointed to by
@var{info} with information about the operating system and host machine.
A non-negative value is returned on successful completion; in the event
of an error, @code{-1} is returned.  The @code{errno} error codes for
this function are the same as those for @code{gethostname}; @pxref{wherever}.
@end deftypefun


@node Controlling Terminal Identification
@subsection Controlling Terminal Identification

You can use the @code{ctermid} function to get a file name that
corresponds to the controlling terminal for the current process.
@xref{Job Control}, for more detailed information about how the
controlling terminal of a process is determined.  This function is
declared in the header file @file{<stdio.h>}.

@comment stdio.h
@comment POSIX.1
@deftypefun {char *} ctermid (char *@var{string})
The @code{ctermid} function returns a string containing the file name of
the controlling terminal for the current process.  If @var{string} is
not a null pointer, it should be an array that can hold at least
@code{L_ctermid} characters; the string is returned in this array.
Otherwise, a pointer to a string in a static area is returned, which
might get overwritten on subsequent calls to this function.

An empty string is returned if the file name cannot be determined for
any reason.  Even if a file name is returned, access to the file it
represents is not guaranteed.
@end deftypefun

@comment stdio.h
@comment POSIX.1
@defvr Macro L_ctermid
The value of this macro is an integer constant expression that
represents the size of a string large enough to hold the file name
returned by @code{ctermid}.
@end defvr

See also the @code{isatty} and @code{ttyname} functions, in 
@ref{Terminal Identification}.


@node System Parameters
@section System Parameters

The POSIX.1 standard specifies a number of symbolic constants that
represent the values for certain system limits, such as the maximum
number of simultaneous processes per user.  However, some of these
limits might not really be constant in a given implementation.  In a
typical Unix environment, for example, the values are determined from a
configuration file used in building the operating system kernel, and can
be changed without invalidating already-compiled programs by rebooting
the machine with a different kernel.  Other parameters might depend on
the amount of memory available.

In order to deal with the problem of variable limits, for most of these
parameters there is one symbolic constant that defines the most
restrictive limit permissible by the POSIX standard.  If the actual
limit placed by a particular implementation for that parameter is a
constant, then it defines another symbolic constant to represent it.
Otherwise, the actual limit can be requested at runtime by calling the
@code{sysconf} function.

Definitions for the following macros appear in the header file
@file{<limits.h>}.  The values of the macros are all integer constants.

@strong{Incomplete:}  What does the GNU system do for the 
implementation-defined macros?

@comment limits.h
@comment POSIX.1
@defvr Macro _POSIX_ARG_MAX
The value of this macro is the most restrictive limit permitted by POSIX
for the maximum combined length of the @var{argv} and @var{environ}
arguments that can be passed to the @code{exec} functions.  The value of
this constant is @code{4096}.
@end defvr

@comment limits.h
@comment POSIX.1
@defvr Macro ARG_MAX
This is the actual implementation limit corresponding to
@code{_POSIX_ARG_MAX}, but is defined only if the limit for the
particular implementation is a constant.
@end defvr

@comment limits.h
@comment POSIX.1
@defvr Macro _POSIX_CHILD_MAX
The value of this macro is the most restrictive limit permitted by POSIX
for the maximum number of simultaneous processes per real user ID.  Its
value is @code{6}.
@end defvr

@comment limits.h
@comment POSIX.1
@defvr Macro CHILD_MAX
This is the actual implementation limit corresponding to
@code{_POSIX_CHILD_MAX}, but is defined only if the limit for the
particular implementation is a constant.
@end defvr

@comment limits.h
@comment POSIX.1
@defvr Macro _POSIX_OPEN_MAX
The value of this macro is the most restrictive limit permitted by POSIX
for the maximum number of files that a single process can have open
simultaneously.  The value of this constant is @code{16}.
@end defvr

@comment limits.h
@comment POSIX.1
@defvr Macro OPEN_MAX
This is the actual implementation limit corresponding to
@code{_POSIX_OPEN_MAX}, but is defined only if the limit for the
particular implementation is a constant.
@end defvr

@comment limits.h
@comment POSIX.1
@defvr Macro _POSIX_STREAM_MAX
The value of this macro is the most restrictive limit permitted by POSIX
for the maximum number of streams that a single process can have open
simultaneously.  The value of this constant is @code{8}.
@end defvr

@comment limits.h
@comment POSIX.1
@defvr Macro STREAM_MAX
This is the actual implementation limit corresponding to
@code{_POSIX_STREAM_MAX}, but is defined only if the limit for the
particular implementation is a constant.
@end defvr

@comment limits.h
@comment POSIX.1
@defvr Macro _POSIX_TZNAME_MAX
The value of this macro is the most restrictive limit permitted by POSIX
for the maximum length of a time zone name.  The value of this constant
is @code{3}.
@end defvr

@comment limits.h
@comment POSIX.1
@defvr Macro TZNAME_MAX
This is the actual implementation limit corresponding to
@code{_POSIX_TZNAME_MAX}, but is defined only if the limit for the
particular implementation is a constant.
@end defvr

@comment limits.h
@comment POSIX.1
@defvr Macro _POSIX_NGROUPS_MAX
The value of this macro is the most restrictive limit permitted by POSIX
for the maximum number of supplementary group IDs per process.  The
value of the constant is @code{0}.
@end defvr

@comment limits.h
@comment POSIX.1
@defvr Macro NGROUPS_MAX
This corresponds to @code{_POSIX_NGROUPS_MAX}, but represents the
minimum value guaranteed by the implementation.  This macro is defined
even if the limit for the particular implementation is not a constant.
(The actual maximum might be larger, and can be accessed with the
@code{sysconf} function.)
@end defvr

@comment limits.h
@comment POSIX.1
@defvr Macro _POSIX_SSIZE_MAX
The value of this macro is the most restrictive limit permitted by POSIX
for the maximum value that can be stored in an object of type @code{ssize_t}.
(Effectively, this is the limit on the number of bytes that can be read
or written in a single operation.  The value of this constant is
@code{32767}.
@end defvr

@comment limits.h
@comment POSIX.1
@defvr Macro SSIZE_MAX
This is the actual implementation limit corresponding to
@code{_POSIX_SSIZE_MAX}.  This macro is always defined and its value is
a constant within a given implementation.
@end defvr

Definitions for these additional macros that describe system parameters
appear in the header file @file{<unistd.h>}.

@comment unistd.h
@comment POSIX.1
@defvr Macro _POSIX_JOB_CONTROL
If this symbol is defined, it indicates that the system supports job
control.  Otherwise, the implementation behaves as if all processes
within a session belong to a single process group.  @xref{Job Control}.
@end defvr

@comment unistd.h
@comment POSIX.1
@defvr Macro _POSIX_SAVED_IDS
If this symbol is defined, it indicates that the system remembers the
effective user and group IDs of an executable file with the set-user-ID
or set-group-ID bits set, and that explicitly changing the effective
user or group IDs back to these values is permitted.  If this option is
not defined, then if a nonprivileged process changes its effective user
or group ID to the real user or group ID of the process, it can't change
it back again.  @xref{User/Group IDs of a Process}.
@end defvr

@comment unistd.h
@comment POSIX.1
@defvr Macro _POSIX_VERSION
This constant represents the version of the POSIX standard to which
the implementation conforms.  For an implementation conforming to the
1990 POSIX.1 standard, the value is the integer @code{199009L}.
@end defvr

You can request the actual runtime values of these parameters using the
@code{sysconf} function.  This function and the macros for use as its
@var{parameter} argument are declared in the header file
@file{<unistd.h>}.

@comment unistd.h
@comment POSIX.1
@deftypefun long sysconf (int @var{parameter})
This function is used to inquire about runtime system parameters.
The @var{parameter} argument can be one of the following:

@table @code
@item _SC_ARG_MAX
Return the value corresponding to @code{ARG_MAX}.

@item _SC_CHILD_MAX
Return the value corresponding to @code{CHILD_MAX}.

@item _SC_OPEN_MAX
Return the value corresponding to @code{OPEN_MAX}.

@item _SC_STREAM_MAX
Return the value corresponding to @code{STREAM_MAX}.

@item _SC_TZNAME_MAX
Return the value corresponding to @code{TZNAME_MAX}.

@item _SC_NGROUPS_MAX
Return the value corresponding to @code{NGROUPS_MAX}.

@item _SC_JOB_CONTROL
Return the value corresponding to @code{_POSIX_JOB_CONTROL}.

@item _SC_SAVED_IDS
Return the value corresponding to @code{_POSIX_SAVED_IDS}.

@item _SC_VERSION
Return the value corresponding to @code{_POSIX_VERSION}.

@item _SC_CLK_TCK
Return the value corresponding to @code{CLOCKS_PER_SEC}.
@end table

The normal return value from @code{sysconf} is the value you requested.
A value of @code{-1} is returned both if the implementation does not
impose a limit, and in case of an error.  

The following @code{errno} error conditions are defined for this function:
@table @code
@item EINVAL
The value of the @var{parameter} is invalid.
@end table
@end deftypefun

These symbolic constants are defined for use as the @var{parameter}
argument to @code{sysconf}.  The values are all integer constants.

@comment unistd.h
@comment POSIX.1
@defvr Macro _SC_ARG_MAX
Inquire about the parameter corresponding to @code{ARG_MAX}.
@end defvr

@comment unistd.h
@comment POSIX.1
@defvr Macro _SC_CHILD_MAX
Inquire about the parameter corresponding to @code{CHILD_MAX}.
@end defvr

@comment unistd.h
@comment POSIX.1
@defvr Macro _SC_OPEN_MAX
Inquire about the parameter corresponding to @code{OPEN_MAX}.
@end defvr

@comment unistd.h
@comment POSIX.1
@defvr Macro _SC_STREAM_MAX
Inquire about the parameter corresponding to @code{STREAM_MAX}.
@end defvr

@comment unistd.h
@comment POSIX.1
@defvr Macro _SC_TZNAME_MAX
Inquire about the parameter corresponding to @code{TZNAME_MAX}.
@end defvr

@comment unistd.h
@comment POSIX.1
@defvr Macro _SC_NGROUPS_MAX
Inquire about the parameter corresponding to @code{NGROUPS_MAX}.
@end defvr

@comment unistd.h
@comment POSIX.1
@defvr Macro _SC_JOB_CONTROL
Inquire about the parameter corresponding to @code{_POSIX_JOB_CONTROL}.
@end defvr

@comment unistd.h
@comment POSIX.1
@defvr Macro _SC_SAVED_IDS
Inquire about the parameter corresponding to @code{_POSIX_SAVED_IDS}.
@end defvr

@comment unistd.h
@comment POSIX.1
@defvr Macro _SC_VERSION
Inquire about the parameter corresponding to @code{_POSIX_VERSION}.
@end defvr

@comment unistd.h
@comment POSIX.1
@defvr Macro _SC_CLK_TCK
Inquire about the parameter corresponding to @code{CLOCKS_PER_SEC};
@pxref{Basic Elapsed CPU Time Inquiry}.
@end defvr

@strong{Incomplete:}  There are also a bunch of symbols for POSIX.2
features listed in @file{<unistd.h>}.
